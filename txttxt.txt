
[unalloc_21_270336_129388032, is designed to deal with systems which treat some
    # 'filenames' in a special way. For example VMS 'Logical Names'
    # (something like unix environment variables - but different).
    # This function should recognise such names and expand them into
    # full file paths.
    # Must return undef if $spec is invalid or file does not exist.
    my $file = $spec; # default output to input
    
	return undef unless -f $file;
    
    print STDERR "dl_expandspec($spec) => $file\n" if $dl_debug;
    $file;
sub dl_find_symbol_anywhere
    my $sym = shift;
    my $libref;
    foreach $libref (@dl_librefs) {
	my $symref = dl_find_symbol($libref,$sym);
	return $symref if $symref;
    }
    return undef;
#line 775
FILE
67f6ea16/Errno.pm
{#line 1 "C:/Perl/lib/Errno.pm"
# This file is auto-generated. ***ANY*** changes here will be lost
package Errno;
our (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);
use Exporter ();
use Config;
use strict;
"$Config{'archname'}-$Config{'osvers'}" eq
"MSWin32-x86-multi-thread-5.00" or
	die "Errno architecture (MSWin32-x86-multi-thread-5.00) does not match executable architecture ($Config{'archname'}-$Config{'osvers'})";
$VERSION = "1.10";
$VERSION = eval $VERSION;
@ISA = qw(Exporter);
@EXPORT_OK = qw(EROFS ESHUTDOWN EPROTONOSUPPORT ENFILE ENOLCK
	EADDRINUSE ECONNABORTED EBADF EDEADLK ENOTDIR EINVAL ENOTTY EXDEV
	ELOOP ECONNREFUSED EISCONN EFBIG ECONNRESET EPFNOSUPPORT ENOENT
	EDISCON EWOULDBLOCK EDOM EMSGSIZE EDESTADDRREQ ENOTSOCK EIO ENOSPC
	ENOBUFS EINPROGRESS ERANGE EADDRNOTAVAIL EAFNOSUPPORT ENOSYS EINTR
	EHOSTDOWN EREMOTE EILSEQ ENOMEM ENOTCONN ENETUNREACH EPIPE ESTALE
	EDQUOT EUSERS EOPNOTSUPP ESPIPE EALREADY EMFILE ENAMETOOLONG EACCES
	ENOEXEC EISDIR EPROCLIM EBUSY E2BIG EPERM EEXIST ETOOMANYREFS
	ESOCKTNOSUPPORT ETIMEDOUT ENXIO ESRCH ENODEV EFAULT EAGAIN EMLINK
	EDEADLOCK ENOPROTOOPT ECHILD ENETDOWN EHOSTUNREACH EPROTOTYPE
	ENETRESET ENOTEMPTY);
%EXPORT_TAGS = (
    POSIX => [qw(
	E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY
	EBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
	EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH
	EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
	EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS
	ENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTCONN
	ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM EPFNOSUPPORT
	EPIPE EPROCLIM EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE EROFS
	ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT ETOOMANYREFS
	EUSERS EWOULDBLOCK EXDEV
    )]
sub EPERM () { 1 }
sub ENOENT () { 2 }
sub ESRCH () { 3 }
sub EINTR () { 4 }
sub EIO () { 5 }
sub ENXIO () { 6 }
sub E2BIG () { 7 }
sub ENOEXEC () { 8 }
sub EBADF () { 9 }
sub ECHILD () { 10 }
sub EAGAIN () { 11 }
sub ENOMEM () { 12 }
sub EACCES () { 13 }
sub EFAULT () { 14 }
sub EBUSY () { 16 }
sub EEXIST () { 17 }
sub EXDEV () { 18 }
sub ENODEV () { 19 }
sub ENOTDIR () { 20 }
sub EISDIR () { 21 }
sub EINVAL () { 22 }
sub ENFILE () { 23 }
sub EMFILE () { 24 }
sub ENOTTY () { 25 }
sub EFBIG () { 27 }
sub ENOSPC () { 28 }
sub ESPIPE () { 29 }
sub EROFS () { 30 }
sub EMLINK () { 31 }
sub EPIPE () { 32 }
sub EDOM () { 33 }
sub ERANGE () { 34 }
sub EDEADLK () { 36 }
sub EDEADLOCK () { 36 }
sub ENAMETOOLONG () { 38 }
sub ENOLCK () { 39 }
sub ENOSYS () { 40 }
sub ENOTEMPTY () { 41 }
sub EILSEQ () { 42 }
sub EWOULDBLOCK () { 10035 }
sub EINPROGRESS () { 10036 }
sub EALREADY () { 10037 }
sub ENOTSOCK () { 10038 }
sub EDESTADDRREQ () { 10039 }
sub EMSGSIZE () { 10040 }
sub EPROTOTYPE () { 10041 }
sub ENOPROTOOPT () { 10042 }
sub EPROTONOSUPPORT () { 10043 }
sub ESOCKTNOSUPPORT () { 10044 }
sub EOPNOTSUPP () { 10045 }
sub EPFNOSUPPORT () { 10046 }
sub EAFNOSUPPORT () { 10047 }
sub EADDRINUSE () { 10048 }
sub EADDRNOTAVAIL () { 10049 }
sub ENETDOWN () { 10050 }
sub ENETUNREACH () { 10051 }
sub ENETRESET () { 10052 }
sub ECONNABORTED () { 10053 }
sub ECONNRESET () { 10054 }
sub ENOBUFS () { 10055 }
sub EISCONN () { 10056 }
sub ENOTCONN () { 10057 }
sub ESHUTDOWN () { 10058 }
sub ETOOMANYREFS () { 10059 }
sub ETIMEDOUT () { 10060 }
sub ECONNREFUSED () { 10061 }
sub ELOOP () { 10062 }
sub EHOSTDOWN () { 10064 }
sub EHOSTUNREACH () { 10065 }
sub EPROCLIM () { 10067 }
sub EUSERS () { 10068 }
sub EDQUOT () { 10069 }
sub ESTALE () { 10070 }
sub EREMOTE () { 10071 }
sub EDISCON () { 10101 }
sub TIEHASH { bless [] }
sub FETCH {
    my ($self, $errname) = @_;
    my $proto = prototype("Errno::$errname");
    my $errno = "";
    if (defined($proto) && $proto eq "") {
	no strict 'refs';
	$errno = &$errname;
        $errno = 0 unless $! == $errno;
    }
    return $errno;
sub STORE {
    require Carp;
    Carp::confess("ERRNO hash is read only!");
*CLEAR = \&STORE;
*DELETE = \&STORE;
sub NEXTKEY {
    my($k,$v);
    while(($k,$v) = each %Errno::) {
	my $proto = prototype("Errno::$k");
	last if (defined($proto) && $proto eq "");
    }
    $k
sub FIRSTKEY {
    my $s = scalar keys %Errno::;	# initialize iterator
    goto &NEXTKEY;
sub EXISTS {
    my ($self, $errname) = @_;
    my $r = ref $errname;
    my $proto = !$r || $r eq 'CODE' ? prototype($errname) : undef;
    defined($proto) && $proto eq "";
tie %!, __PACKAGE__;
__END__
#line 222
FILE
5f5f3678/Exporter.pm
	w#line 1 "C:/Perl/lib/Exporter.pm"
package Exporter;
require 5.006;
# Be lean.
#use strict;
#no strict 'refs';
our $Debug = 0;
our $ExportLevel = 0;
our $Verbose ||= 0;
our $VERSION = '5.62';
our (%Cache);
# Carp does this now for us, so we can finally live w/o Carp
#$Carp::Internal{Exporter} = 1;
sub as_heavy {
  require Exporter::Heavy;
  # Unfortunately, this does not work if the caller is aliased as *name = \&foo
  # Thus the need to create a lot of identical subroutines
  my $c = (caller(1))[3];
  $c =~ s/.*:://;
  \&{"Exporter::Heavy::heavy_$c"};
sub export {
  goto &{as_heavy()};
sub import {
  my $pkg = shift;
  my $callpkg = caller($ExportLevel);
  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    *{$callpkg."::import"} = \&import;
    return;
  # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  return export $pkg, $callpkg, @_
    if $Verbose or $Debug or @$fail > 1;
  my $export_cache = ($Cache{$pkg} ||= {});
  my $args = @_ or @_ = @$exports;
  local $_;
  if ($args and not %$export_cache) {
    s/^&//, $export_cache->{$_} = 1
      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
  my $heavy;
  # Try very hard not to use {} and hence have to  enter scope on the foreach
  # We bomb out of the loop with last as soon as heavy is set.
  if ($args or $fail) {
    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
               or @$fail and $_ eq $fail->[0])) and last
                 foreach (@_);
  } else {
    ($heavy = /\W/) and last
      foreach (@_);
  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
  local $SIG{__WARN__} = 
	sub {require Carp; &Carp::carp};
  # shortcut for the common case of no type character
  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
# Default methods
sub export_fail {
    my $self = shift;
    @_;
# Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
# *name = \&foo.  Thus the need to create a lot of identical subroutines
# Otherwise we could have aliased them to export().
sub export_to_level {
  goto &{as_heavy()};
sub export_tags {
  goto &{as_heavy()};
sub export_ok_tags {
  goto &{as_heavy()};
sub require_version {
  goto &{as_heavy()};
__END__
#line 584
FILE
8ba4c2ca/Exporter/Heavy.pm
#line 1 "C:/Perl/lib/Exporter/Heavy.pm"
package Exporter::Heavy;
use strict;
no strict 'refs';
# On one line so MakeMaker will see it.
require Exporter;  our $VERSION = $Exporter::VERSION;
# Carp does this now for us, so we can finally live w/o Carp
#$Carp::Internal{"Exporter::Heavy"} = 1;
#line 24
# We go to a lot of trouble not to 'require Carp' at file scope,
#  because Carp requires Exporter, and something has to give.
sub _rebuild_cache {
    my ($pkg, $exports, $cache) = @_;
    s/^&// foreach @$exports;
    @{$cache}{@$exports} = (1) x @$exports;
    my $ok = \@{"${pkg}::EXPORT_OK"};
    if (@$ok) {
	s/^&// foreach @$ok;
	@{$cache}{@$ok} = (1) x @$ok;
    }
sub heavy_export {
    # First make import warnings look like they're coming from the "use".
    local $SIG{__WARN__} = sub {
	my $text = shift;
	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
	    require Carp;
	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
	    Carp::carp($text);
	else {
	    warn $text;
    };
    local $SIG{__DIE__} = sub {
	require Carp;
	local $Carp::CarpLevel = 1;	# ignore package calling us too.
	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
    };
    my($pkg, $callpkg, @imports) = @_;
    my($type, $sym, $cache_is_current, $oops);
    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                   $Exporter::Cache{$pkg} ||= {});
    if (@imports) {
	if (!%$export_cache) {
	    _rebuild_cache ($pkg, $exports, $export_cache);
	    $cache_is_current = 1;
	if (grep m{^[/!:]}, @imports) {
	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
	    my $tagdata;
	    my %imports;
	    my($remove, $spec, @names, @allexports);
	    # negated first item implies starting with default set:
	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
	    foreach $spec (@imports){
		$remove = $spec =~ s/^!//;
		if ($spec =~ s/^://){
		    if ($spec eq 'DEFAULT'){
			@names = @$exports;
		    }
		    elsif ($tagdata = $tagsref->{$spec}) {
			@names = @$tagdata;
		    }
		    else {
			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
			++$oops;
			next;
		    }
		elsif ($spec =~ m:^/(.*)/$:){
		    my $patn = $1;
		    @allexports = keys %$export_cache unless @allexports; # only do keys once
		    @names = grep(/$patn/, @allexports); # not anchored by default
		else {
		    @names = ($spec); # is a normal symbol name
		warn "Import ".($remove ? "del":"add").": @names "
		    if $Exporter::Verbose;
		if ($remove) {
		   foreach $sym (@names) { delete $imports{$sym} } 
		else {
		    @imports{@names} = (1) x @names;
	    }
	    @imports = keys %imports;
        my @carp;
	foreach $sym (@imports) {
	    if (!$export_cache->{$sym}) {
		if ($sym =~ m/^\d/) {
		    $pkg->VERSION($sym); # inherit from UNIVERSAL
		    # If the version number was the only thing specified
		    # then we should act as if nothing was specified:
		    if (@imports == 1) {
			@imports = @$exports;
			last;
		    }
		    # We need a way to emulate 'use Foo ()' but still
		    # allow an easy version check: "use Foo 1.23, ''";
		    if (@imports == 2 and !$imports[1]) {
			@imports = ();
			last;
		    }
		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
		    # Last chance - see if they've updated EXPORT_OK since we
		    # cached it.
		    unless ($cache_is_current) {
			%$export_cache = ();
			_rebuild_cache ($pkg, $exports, $export_cache);
			$cache_is_current = 1;
		    }
		    if (!$export_cache->{$sym}) {
			# accumulate the non-exports
			push @carp,
			  qq["$sym" is not exported by the $pkg module\n];
			$oops++;
		    }
	    }
	if ($oops) {
	    require Carp;
	    Carp::croak("@{carp}Can't continue after import errors");
    }
    else {
	@imports = @$exports;
    }
    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                              $Exporter::FailCache{$pkg} ||= {});
    if (@$fail) {
	if (!%$fail_cache) {
	    # Build cache of symbols. Optimise the lookup by adding
	    # barewords twice... both with and without a leading &.
	    # (Technique could be applied to $export_cache at cost of memory)
	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
	    @{$fail_cache}{@expanded} = (1) x @expanded;
	my @failed;
	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
	if (@failed) {
	    @failed = $pkg->export_fail(@failed);
	    foreach $sym (@failed) {
                require Carp;
		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
			"on this architecture");
	    }
	    if (@failed) {
		require Carp;
		Carp::croak("Can't continue after import errors");
	    }
    }
    warn "Importing into $callpkg from $pkg: ",
		join(", ",sort @imports) if $Exporter::Verbose;
    foreach $sym (@imports) {
	# shortcut for the common case of no type character
	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
	    unless $sym =~ s/^(\W)//;
	$type = $1;
	no warnings 'once';
	*{"${callpkg}::$sym"} =
	    $type eq '&' ? \&{"${pkg}::$sym"} :
	    $type eq '$' ? \${"${pkg}::$sym"} :
	    $type eq '@' ? \@{"${pkg}::$sym"} :
	    $type eq '%' ? \%{"${pkg}::$sym"} :
	    $type eq '*' ?  *{"${pkg}::$sym"} :
	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
    }
sub heavy_export_to_level
      my $pkg = shift;
      my $level = shift;
      (undef) = shift;			# XXX redundant arg
      my $callpkg = caller($level);
      $pkg->export($callpkg, @_);
# Utility functions
sub _push_tags {
    my($pkg, $var, $syms) = @_;
    my @nontag = ();
    my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
    push(@{"${pkg}::$var"},
	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                 : scalar(push(@nontag,$_),$_) }
		(@$syms) ? @$syms : keys %$export_tags);
    if (@nontag and $^W) {
	# This may change to a die one day
	require Carp;
	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
    }
sub heavy_require_version {
    my($self, $wanted) = @_;
    my $pkg = ref $self || $self;
    return ${pkg}->VERSION($wanted);
sub heavy_export_tags {
  _push_tags((caller)[0], "EXPORT",    \@_);
sub heavy_export_ok_tags {
  _push_tags((caller)[0], "EXPORT_OK", \@_);
FILE
2b183ef0/Fcntl.pm
#line 1 "C:/Perl/lib/Fcntl.pm"
package Fcntl;
#line 57
use strict;
our($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);
require Exporter;
use XSLoader ();
@ISA = qw(Exporter);
BEGIN {
  $VERSION = "1.06";
# Items to export into callers namespace by default
# (move infrequently used names to @EXPORT_OK below)
@EXPORT =
  qw(
	FD_CLOEXEC
	F_ALLOCSP
	F_ALLOCSP64
	F_COMPAT
	F_DUP2FD
	F_DUPFD
	F_EXLCK
	F_FREESP
	F_FREESP64
	F_FSYNC
	F_FSYNC64
	F_GETFD
	F_GETFL
	F_GETLK
	F_GETLK64
	F_GETOWN
	F_NODNY
	F_POSIX
	F_RDACC
	F_RDDNY
	F_RDLCK
	F_RWACC
	F_RWDNY
	F_SETFD
	F_SETFL
	F_SETLK
	F_SETLK64
	F_SETLKW
	F_SETLKW64
	F_SETOWN
	F_SHARE
	F_SHLCK
	F_UNLCK
	F_UNSHARE
	F_WRACC
	F_WRDNY
	F_WRLCK
	O_ACCMODE
	O_ALIAS
	O_APPEND
	O_ASYNC
	O_BINARY
	O_CREAT
	O_DEFER
	O_DIRECT
	O_DIRECTORY
	O_DSYNC
	O_EXCL
	O_EXLOCK
	O_LARGEFILE
	O_NDELAY
	O_NOCTTY
	O_NOFOLLOW
	O_NOINHERIT
	O_NONBLOCK
	O_RANDOM
	O_RAW
	O_RDONLY
	O_RDWR
	O_RSRC
	O_RSYNC
	O_SEQUENTIAL
	O_SHLOCK
	O_SYNC
	O_TEMPORARY
	O_TEXT
	O_TRUNC
	O_WRONLY
     );
# Other items we are prepared to export if requested
@EXPORT_OK = qw(
	DN_ACCESS
	DN_ATTRIB
	DN_CREATE
	DN_DELETE
	DN_MODIFY
	DN_MULTISHOT
	DN_RENAME
	FAPPEND
	FASYNC
	FCREAT
	FDEFER
	FDSYNC
	FEXCL
	FLARGEFILE
	FNDELAY
	FNONBLOCK
	FRSYNC
	FSYNC
	FTRUNC
	F_GETLEASE
	F_GETSIG
	F_NOTIFY
	F_SETLEASE
	F_SETSIG
	LOCK_EX
	LOCK_MAND
	LOCK_NB
	LOCK_READ
	LOCK_RW
	LOCK_SH
	LOCK_UN
	LOCK_WRITE
	O_IGNORE_CTTY
	O_NOATIME
	O_NOLINK
	O_NOTRANS
	SEEK_CUR
	SEEK_END
	SEEK_SET
	S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
	S_IREAD S_IWRITE S_IEXEC
	S_IRGRP S_IWGRP S_IXGRP S_IRWXG
	S_IROTH S_IWOTH S_IXOTH S_IRWXO
	S_IRUSR S_IWUSR S_IXUSR S_IRWXU
	S_ISUID S_ISGID S_ISVTX S_ISTXT
	_S_IFMT S_IFREG S_IFDIR S_IFLNK
	&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO
	&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE
# Named groups of exports
%EXPORT_TAGS = (
    'flock'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],
    'Fcompat' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE
		     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],
    'seek'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],
    'mode'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT
		     _S_IFMT S_IFREG S_IFDIR S_IFLNK
		     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
		     S_IRUSR S_IWUSR S_IXUSR S_IRWXU
		     S_IRGRP S_IWGRP S_IXGRP S_IRWXG
		     S_IROTH S_IWOTH S_IXOTH S_IRWXO
		     S_IREAD S_IWRITE S_IEXEC
		     S_ISREG S_ISDIR S_ISLNK S_ISSOCK
		     S_ISBLK S_ISCHR S_ISFIFO
		     S_ISWHT S_ISENFMT		
		     S_IFMT S_IMODE
                  )],
# Force the constants to become inlined
BEGIN {
  XSLoader::load 'Fcntl', $VERSION;
sub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }
sub S_IMODE { $_[0] & 07777 }
sub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }
sub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }
sub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }
sub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }
sub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }
sub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }
sub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }
sub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }
sub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }
sub AUTOLOAD {
    (my $constname = $AUTOLOAD) =~ s/.*:://;
    die "&Fcntl::constant not defined" if $constname eq 'constant';
    my ($error, $val) = constant($constname);
    if ($error) {
        my (undef,$file,$line) = caller;
        die "$error at $file line $line.\n";
    }
    no strict 'refs';
    *$AUTOLOAD = sub { $val };
    goto &$AUTOLOAD;
FILE
8122857b/File/Basename.pm
#line 1 "C:/Perl/lib/File/Basename.pm"
#line 36
package File::Basename;
# A bit of juggling to insure that C<use re 'taint';> always works, since
# File::Basename is used during the Perl build, when the re extension may
# not be available.
BEGIN {
  unless (eval { require re; })
    { eval ' sub re::import { $^H |= 0x00100000; } ' } # HINT_RE_TAINT
  import re 'taint';
use strict;
use 5.006;
use warnings;
our(@ISA, @EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(fileparse fileparse_set_fstype basename dirname);
$VERSION = "2.76";
fileparse_set_fstype($^O);
#line 102
sub fileparse {
  my($fullname,@suffices) = @_;
  unless (defined $fullname) {
      require Carp;
      Carp::croak("fileparse(): need a valid pathname");
  my $orig_type = '';
  my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);
  my($taint) = substr($fullname,0,0);  # Is $fullname tainted?
  if ($type eq "VMS" and $fullname =~ m{/} ) {
    # We're doing Unix emulation
    $orig_type = $type;
    $type = 'Unix';
  my($dirpath, $basename);
  if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {
    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/s);
    $dirpath .= '.\\' unless $dirpath =~ /[\\\/]\z/;
  elsif ($type eq "OS2") {
    ($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\/])?)(.*)#s);
    $dirpath = './' unless $dirpath;	# Can't be 0
    $dirpath .= '/' unless $dirpath =~ m#[\\/]\z#;
  elsif ($type eq "MacOS") {
    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);
    $dirpath = ':' unless $dirpath;
  elsif ($type eq "AmigaOS") {
    ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/s);
    $dirpath = './' unless $dirpath;
  elsif ($type eq 'VMS' ) {
    ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
    $dirpath ||= '';  # should always be defined
  else { # Default to Unix semantics.
    ($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);
    if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {
      # dev:[000000] is top of VMS tree, similar to Unix '/'
      # so strip it off and treat the rest as "normal"
      my $devspec  = $1;
      my $remainder = $3;
      ($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);
      $dirpath ||= '';  # should always be defined
      $dirpath = $devspec.$dirpath;
    }
    $dirpath = './' unless $dirpath;
      
  my $tail   = '';
  my $suffix = '';
  if (@suffices) {
    foreach $suffix (@suffices) {
      my $pat = ($igncase ? '(?i)' : '') . "($suffix)\$";
      if ($basename =~ s/$pat//s) {
        $taint .= substr($suffix,0,0);
        $tail = $1 . $tail;
      }
    }
  # Ensure taint is propgated from the path to its pieces.
  $tail .= $taint;
  wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)
            : ($basename .= $taint);
#line 212
sub basename {
  my($path) = shift;
  # From BSD basename(1)
  # The basename utility deletes any prefix ending with the last slash `/'
  # character present in string (after first stripping trailing slashes)
  _strip_trailing_sep($path);
  my($basename, $dirname, $suffix) = fileparse( $path, map("\Q$_\E",@_) );
  # From BSD basename(1)
  # The suffix is not stripped if it is identical to the remaining 
  # characters in string.
  if( length $suffix and !length $basename ) {
      $basename = $suffix;
  # Ensure that basename '/' == '/'
  if( !length $basename ) {
      $basename = $dirname;
  return $basename;
#line 281
sub dirname {
    my $path = shift;
    my($type) = $Fileparse_fstype;
    if( $type eq 'VMS' and $path =~ m{/} ) {
        # Parse as Unix
        local($File::Basename::Fileparse_fstype) = '';
        return dirname($path);
    }
    my($basename, $dirname) = fileparse($path);
    if ($type eq 'VMS') { 
        $dirname ||= $ENV{DEFAULT};
    }
    elsif ($type eq 'MacOS') {
	if( !length($basename) && $dirname !~ /^[^:]+:\z/) {
            _strip_trailing_sep($dirname);
	    ($basename,$dirname) = fileparse $dirname;
	$dirname .= ":" unless $dirname =~ /:\z/;
    }
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        _strip_trailing_sep($dirname);
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    _strip_trailing_sep($dirname);
    }
    elsif ($type eq 'AmigaOS') {
        if ( $dirname =~ /:\z/) { return $dirname }
        chop $dirname;
        $dirname =~ s{[^:/]+\z}{} unless length($basename);
    }
    else {
        _strip_trailing_sep($dirname);
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    _strip_trailing_sep($dirname);
    }
    $dirname;
# Strip the trailing path separator.
sub _strip_trailing_sep  {
    my $type = $Fileparse_fstype;
    if ($type eq 'MacOS') {
        $_[0] =~ s/([^:]):\z/$1/s;
    }
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        $_[0] =~ s/([^:])[\\\/]*\z/$1/;
    }
    else {
        $_[0] =~ s{(.)/*\z}{$1}s;
    }
#line 369
BEGIN {
my @Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);
my @Types = (@Ignore_Case, qw(Unix));
sub fileparse_set_fstype {
    my $old = $Fileparse_fstype;
    if (@_) {
        my $new_type = shift;
        $Fileparse_fstype = 'Unix';  # default
        foreach my $type (@Types) {
            $Fileparse_fstype = $type if $new_type =~ /^$type/i;
        }
        $Fileparse_igncase = 
          (grep $Fileparse_fstype eq $_, @Ignore_Case) ? 1 : 0;
    }
    return $old;
#line 403FILE
b114ea5c/File/Copy.pm
%p#line 1 "C:/Perl/lib/File/Copy.pm"
# File/Copy.pm. Written in 1994 by Aaron Sherman <
ajs@ajs.com>. This
# source code has been placed in the public domain by the author.
# Please be kind and preserve the documentation.
# Additions copyright 1996 by Charles Bailey.  Permission is granted
# to distribute the revised code under the same terms as Perl itself.
package File::Copy;
use 5.006;
use strict;
use warnings;
use File::Spec;
use Config;
our(@ISA, @EXPORT, @EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy);
sub copy;
sub syscopy;
sub cp;
sub mv;
# Note that this module implements only *part* of the API defined by
# the File/Copy.pm module of the File-Tools-2.0 package.  However, that
# package has not yet been updated to work with Perl 5.004, and so it
# would be a Bad Thing for the CPAN module to grab it and replace this
# module.  Therefore, we set this module's version higher than 2.0.
$VERSION = '2.11';
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(copy move);
@EXPORT_OK = qw(cp mv);
$Too_Big = 1024 * 1024 * 2;
sub croak {
    require Carp;
    goto &Carp::croak;
sub carp {
    require Carp;
    goto &Carp::carp;
my $macfiles;
if ($^O eq 'MacOS') {
	$macfiles = eval { require Mac::MoreFiles };
	warn 'Mac::MoreFiles could not be loaded; using non-native syscopy'
		if $@ && $^W;
sub _catname {
    my($from, $to) = @_;
    if (not defined &basename) {
	require File::Basename;
	import  File::Basename 'basename';
    }
    if ($^O eq 'MacOS') {
	# a partial dir name that's valid only in the cwd (e.g. 'tmp')
	$to = ':' . $to if $to !~ /:/;
    }
    return File::Spec->catfile($to, basename($from));
# _eq($from, $to) tells whether $from and $to are identical
# works for strings and references
sub _eq {
    return $_[0] == $_[1] if ref $_[0] && ref $_[1];
    return $_[0] eq $_[1] if !ref $_[0] && !ref $_[1];
    return "";
sub copy {
    croak("Usage: copy(FROM, TO [, BUFFERSIZE]) ")
      unless(@_ == 2 || @_ == 3);
    my $from = shift;
    my $to = shift;
    my $from_a_handle = (ref($from)
			 ? (ref($from) eq 'GLOB'
			    || UNIVERSAL::isa($from, 'GLOB')
                            || UNIVERSAL::isa($from, 'IO::Handle'))
			 : (ref(\$from) eq 'GLOB'));
    my $to_a_handle =   (ref($to)
			 ? (ref($to) eq 'GLOB'
			    || UNIVERSAL::isa($to, 'GLOB')
                            || UNIVERSAL::isa($to, 'IO::Handle'))
			 : (ref(\$to) eq 'GLOB'));
    if (_eq($from, $to)) { # works for references, too
	carp("'$from' and '$to' are identical (not copied)");
        # The "copy" was a success as the source and destination contain
        # the same data.
        return 1;
    }
    if ((($Config{d_symlink} && $Config{d_readlink}) || $Config{d_link}) &&
	!($^O eq 'MSWin32' || $^O eq 'os2')) {
	my @fs = stat($from);
	if (@fs) {
	    my @ts = stat($to);
	    if (@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1]) {
		carp("'$from' and '$to' are identical (not copied)");
                return 0;
	    }
    }
    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
	$to = _catname($from, $to);
    }
    if (defined &syscopy && !$Syscopy_is_copy
	&& !$to_a_handle
	&& !($from_a_handle && $^O eq 'os2' )	# OS/2 cannot handle handles
	&& !($from_a_handle && $^O eq 'mpeix')	# and neither can MPE/iX.
	&& !($from_a_handle && $^O eq 'MSWin32')
	&& !($from_a_handle && $^O eq 'MacOS')
	&& !($from_a_handle && $^O eq 'NetWare')
       )
    {
	my $copy_to = $to;
        if ($^O eq 'VMS' && -e $from) {
            if (! -d $to && ! -d $from) {
                # VMS has sticky defaults on extensions, which means that
                # if there is a null extension on the destination file, it
                # will inherit the extension of the source file
                # So add a '.' for a null extension.
                $copy_to = VMS::Filespec::vmsify($to);
                my ($vol, $dirs, $file) = File::Spec->splitpath($copy_to);
                $file = $file . '.' unless ($file =~ /(?<!\^)\./);
                $copy_to = File::Spec->catpath($vol, $dirs, $file);
                # Get rid of the old versions to be like UNIX
                1 while unlink $copy_to;
            }
        }
        return syscopy($from, $copy_to);
    }
    my $closefrom = 0;
    my $closeto = 0;
    my ($size, $status, $r, $buf);
    local($\) = '';
    my $from_h;
    if ($from_a_handle) {
       $from_h = $from;
    } else {
	$from = _protect($from) if $from =~ /^\s/s;
       $from_h = \do { local *FH };
       open($from_h, "< $from\0") or goto fail_open1;
       binmode $from_h or die "($!,$^E)";
	$closefrom = 1;
    }
    my $to_h;
    if ($to_a_handle) {
       $to_h = $to;
    } else {
	$to = _protect($to) if $to =~ /^\s/s;
       $to_h = \do { local *FH };
       open($to_h,"> $to\0") or goto fail_open2;
       binmode $to_h or die "($!,$^E)";
	$closeto = 1;
    }
    if (@_) {
	$size = shift(@_) + 0;
	croak("Bad buffer size for copy: $size\n") unless ($size > 0);
    } else {
	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
	$size = 1024 if ($size < 512);
	$size = $Too_Big if ($size > $Too_Big);
    }
    $! = 0;
    for (;;) {
	my ($r, $w, $t);
       defined($r = sysread($from_h, $buf, $size))
	    or goto fail_inner;
	last unless $r;
	for ($w = 0; $w < $r; $w += $t) {
           $t = syswrite($to_h, $buf, $r - $w, $w)
		or goto fail_inner;
    }
    close($to_h) || goto fail_open2 if $closeto;
    close($from_h) || goto fail_open1 if $closefrom;
    # Use this idiom to avoid uninitialized value warning.
    return 1;
    # All of these contortions try to preserve error messages...
  fail_inner:
    if ($closeto) {
	$status = $!;
	$! = 0;
       close $to_h;
	$! = $status unless $!;
    }
  fail_open2:
    if ($closefrom) {
	$status = $!;
	$! = 0;
       close $from_h;
	$! = $status unless $!;
    }
  fail_open1:
    return 0;
sub move {
    croak("Usage: move(FROM, TO) ") unless @_ == 2;
    my($from,$to) = @_;
    my($fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);
    if (-d $to && ! -d $from) {
	$to = _catname($from, $to);
    }
    ($tosz1,$tomt1) = (stat($to))[7,9];
    $fromsz = -s $from;
    if ($^O eq 'os2' and defined $tosz1 and defined $fromsz) {
      # will not rename with overwrite
      unlink $to;
    }
    my $rename_to = $to;
    if (-$^O eq 'VMS' && -e $from) {
        if (! -d $to && ! -d $from) {
            # VMS has sticky defaults on extensions, which means that
            # if there is a null extension on the destination file, it
            # will inherit the extension of the source file
            # So add a '.' for a null extension.
            $rename_to = VMS::Filespec::vmsify($to);
            my ($vol, $dirs, $file) = File::Spec->splitpath($rename_to);
            $file = $file . '.' unless ($file =~ /(?<!\^)\./);
            $rename_to = File::Spec->catpath($vol, $dirs, $file);
            # Get rid of the old versions to be like UNIX
            1 while unlink $rename_to;
        }
    }
    return 1 if rename $from, $rename_to;
    # Did rename return an error even though it succeeded, because $to
    # is on a remote NFS file system, and NFS lost the server's ack?
    return 1 if defined($fromsz) && !-e $from &&           # $from disappeared
                (($tosz2,$tomt2) = (stat($to))[7,9]) &&    # $to's there
                  ((!defined $tosz1) ||			   #  not before or
		   ($tosz1 != $tosz2 or $tomt1 != $tomt2)) &&  #   was changed
                $tosz2 == $fromsz;                         # it's all there
    ($tosz1,$tomt1) = (stat($to))[7,9];  # just in case rename did something
    {
        local $@;
        eval {
            local $SIG{__DIE__};
            copy($from,$to) or die;
            my($atime, $mtime) = (stat($from))[8,9];
            utime($atime, $mtime, $to);
            unlink($from)   or die;
        };
        return 1 unless $@;
    }
    ($sts,$ossts) = ($! + 0, $^E + 0);
    ($tosz2,$tomt2) = ((stat($to))[7,9],0,0) if defined $tomt1;
    unlink($to) if !defined($tomt1) or $tomt1 != $tomt2 or $tosz1 != $tosz2;
    ($!,$^E) = ($sts,$ossts);
    return 0;
*cp = \&copy;
*mv = \&move;
if ($^O eq 'MacOS') {
    *_protect = sub { MacPerl::MakeFSSpec($_[0]) };
} else {
    *_protect = sub { "./$_[0]" };
# &syscopy is an XSUB under OS/2
unless (defined &syscopy) {
    if ($^O eq 'VMS') {
	*syscopy = \&rmscopy;
    } elsif ($^O eq 'mpeix') {
	*syscopy = sub {
	    return 0 unless @_ == 2;
	    # Use the MPE cp program in order to
	    # preserve MPE file attributes.
	    return system('/bin/cp', '-f', $_[0], $_[1]) == 0;
    } elsif ($^O eq 'MSWin32' && defined &DynaLoader::boot_DynaLoader) {
	# Win32::CopyFile() fill only work if we can load Win32.xs
	*syscopy = sub {
	    return 0 unless @_ == 2;]




[unalloc_21_270336_129388032, sitehtml3direxp=''
sitelib='C:\Perl\site\lib'
sitelib_stem=''
sitelibexp='C:\Perl\site\lib'
siteman1dir=''
siteman1direxp=''
siteman3dir=''
siteman3direxp=''
siteprefix='C:\Perl\site'
siteprefixexp='C:\Perl\site'
sitescript=''
sitescriptexp=''
sizesize='4'
sizetype='size_t'
sleep=''
smail=''
so='dll'
sockethdr=''
socketlib=''
socksizetype='int'
sort='sort'
spackage='Perl5'
spitshell=''
srand48_r_proto='0'
srandom_r_proto='0'
src=''
ssizetype='int'
startperl='#!perl'
startsh='#!/bin/sh'
static_ext='Win32CORE'
stdchar='char'
stdio_base='((fp)->_base)'
stdio_bufsiz='((fp)->_cnt + (fp)->_ptr - (fp)->_base)'
stdio_cnt='((fp)->_cnt)'
stdio_filbuf=''
stdio_ptr='((fp)->_ptr)'
stdio_stream_array=''
strerror_r_proto='0'
strings='/usr/include/string.h'
submit=''
subversion=''
sysman='/usr/man/man1'
tail=''
tar=''
targetarch=''
tbl=''
tee=''
test=''
timeincl='/usr/include/sys/time.h '
timetype='time_t'
tmpnam_r_proto='0'
to=':'
touch='touch'
tr=''
trnl='\012'
troff=''
ttyname_r_proto='0'
u16size='2'
u16type='unsigned short'
u32size='4'
u32type='unsigned long'
u64size='8'
u64type='unsigned __int64'
u8size='1'
u8type='unsigned char'
uidformat='"ld"'
uidsign='-1'
uidsize='4'
uidtype='uid_t'
uname='uname'
uniq='uniq'
uquadtype='unsigned __int64'
use5005threads='undef'
use64bitall='undef'
use64bitint='undef'
usecrosscompile='undef'
usedl='define'
usefaststdio='undef'
useithreads='define'
uselargefiles='define'
uselongdouble='undef'
usemallocwrap='define'
usemorebits='undef'
usemultiplicity='define'
usemymalloc='n'
usenm='false'
useopcode='true'
useperlio='define'
useposix='true'
usereentrant='undef'
userelocatableinc='undef'
usesfio='false'
useshrplib='true'
usesitecustomize='define'
usesocks='undef'
usethreads='define'
usevendorprefix='undef'
usevfork='false'
usrinc='/usr/include'
uuname=''
uvXUformat='"lX"'
uvoformat='"lo"'
uvsize='4'
uvtype='unsigned long'
uvuformat='"lu"'
uvxformat='"lx"'
vendorarch=''
vendorarchexp=''
vendorbin=''
vendorbinexp=''
vendorhtml1dir=' '
vendorhtml1direxp=''
vendorhtml3dir=' '
vendorhtml3direxp=''
vendorlib=''
vendorlib_stem=''
vendorlibexp=''
vendorman1dir=' '
vendorman1direxp=''
vendorman3dir=' '
vendorman3direxp=''
vendorprefix=''
vendorprefixexp=''
vendorscript=''
vendorscriptexp=''
version='5.10.0'
version_patchlevel_string='version 10 subversion 0'
versiononly='undef'
vi=''
voidflags='15'
xlibpth='/usr/lib/386 /lib/386'
yacc='yacc'
yaccflags=''
zcat=''
zip='zip'
!END!
my $i = 0;
foreach my $c (4,3,2) { $i |= ord($c); $i <<= 8 }
$i |= ord(1);
our $byteorder = join('', unpack('aaaa', pack('L!', $i)));
s/(byteorder=)(['"]).*?\2/$1$2$Config::byteorder$2/m;
my $config_sh_len = length $_;
our $Config_SH_expanded = "\n$_" . << 'EOVIRTUAL';
ccflags_nolargefiles='-nologo -GF -W3 -MD -Zi -DNDEBUG -O1 -DWIN32 -D_CONSOLE -DNO_STRICT -DHAVE_DES_FCRYPT -DUSE_SITECUSTOMIZE -DPRIVLIB_LAST_IN_INC -DPERL_IMPLICIT_CONTEXT -DPERL_IMPLICIT_SYS -DUSE_PERLIO -DPERL_MSVCRT_READFIX'
ldflags_nolargefiles='-nologo -nodefaultlib -debug -opt:ref,icf  -libpath:"C:\Perl\lib\CORE"  -machine:x86'
libs_nolargefiles=''
libswanted_nolargefiles=''
EOVIRTUAL
# Search for it in the big string
sub fetch_string {
    my($self, $key) = @_;
    # Let ActivePerl::Config override if it wants
    my $value;
    $value = _fetch_string(@_)
        unless defined(&ActivePerl::Config::override) &&
               ActivePerl::Config::override($key, $value);
    return $self->{$key} = $value; # cache it
sub _fetch_string {
    my($self, $key) = @_;
    # We only have ' delimted.
    my $start = index($Config_SH_expanded, "\n$key=\'");
    # Start can never be -1 now, as we've rigged the long string we're
    # searching with an initial dummy newline.
    return undef if $start == -1;
    $start += length($key) + 3;
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "'\n", $start)
		       - $start);
    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    return $value;
my $prevpos = 0;
sub FIRSTKEY {
    $prevpos = 0;
    substr($Config_SH_expanded, 1, index($Config_SH_expanded, '=') - 1 );
sub NEXTKEY {
    my $pos = index($Config_SH_expanded, qq('\n), $prevpos) + 2;
    my $len = index($Config_SH_expanded, "=", $pos) - $pos;
    $prevpos = $pos;
    $len > 0 ? substr($Config_SH_expanded, $pos, $len) : undef;
sub EXISTS {
    return 1 if exists($_[0]->{$_[1]});
    return(index($Config_SH_expanded, "\n$_[1]='") != -1
          );
sub STORE  { die "\%Config::Config is read-only\n" }
*DELETE = \&STORE;
*CLEAR  = \&STORE;
sub config_sh {
    substr $Config_SH_expanded, 1, $config_sh_len;
sub config_re {
    my $re = shift;
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/,
    $Config_SH_expanded;
sub config_vars {
    # implements -V:cfgvar option (see perlrun -V:)
    foreach (@_) {
	# find optional leading, trailing colons; and query-spec
	my ($notag,$qry,$lncont) = m/^(:)?(.*?)(:)?$/;	# flags fore and aft, 
	# map colon-flags to print decorations
	my $prfx = $notag ? '': "$qry=";		# tag-prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# line ending for print
	# all config-vars are by definition \w only, any \W means regex
	if ($qry =~ /\W/) {
	    my @matches = config_re($qry);
	    print map "$_$lnend", @matches ? @matches : "$qry: not found"		if !$notag;
	    print map { s/\w+=//; "$_$lnend" } @matches ? @matches : "$qry: not found"	if  $notag;
	} else {
	    my $v = (exists $Config::Config{$qry}) ? $Config::Config{$qry}
						   : 'UNKNOWN';
	    $v = 'undef' unless defined $v;
	    print "${prfx}'${v}'$lnend";
    }
# Called by the real AUTOLOAD
sub launcher {
    undef &AUTOLOAD;
    goto \&$Config::AUTOLOAD;
FILE
dcb3db9e/Cwd.pm
<F#line 1 "C:/Perl/lib/Cwd.pm"
package Cwd;
#line 169
use strict;
use Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
$VERSION = '3.2501';
@ISA = qw/ Exporter /;
@EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
@EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
# sys_cwd may keep the builtin command
# All the functionality of this module may provided by builtins,
# there is no sense to process the rest of the file.
# The best choice may be to have this in BEGIN, but how to return from BEGIN?
if ($^O eq 'os2') {
    local $^W = 0;
    *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
    *getcwd             = \&cwd;
    *fastgetcwd         = \&cwd;
    *fastcwd            = \&cwd;
    *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
    *abs_path           = \&fast_abs_path;
    *realpath           = \&fast_abs_path;
    *fast_realpath      = \&fast_abs_path;
    return 1;
# If loading the XS stuff doesn't work, we can fall back to pure perl
eval {
  if ( $] >= 5.006 ) {
    require XSLoader;
    XSLoader::load( __PACKAGE__, $VERSION );
  } else {
    require DynaLoader;
    push @ISA, 'DynaLoader';
    __PACKAGE__->bootstrap( $VERSION );
# Must be after the DynaLoader stuff:
$VERSION = eval $VERSION;
# Big nasty table of function aliases
my %METHOD_MAP =
   VMS =>
   {
    cwd			=> '_vms_cwd',
    getcwd		=> '_vms_cwd',
    fastcwd		=> '_vms_cwd',
    fastgetcwd		=> '_vms_cwd',
    abs_path		=> '_vms_abs_path',
    fast_abs_path	=> '_vms_abs_path',
   },
   MSWin32 =>
   {
    # We assume that &_NT_cwd is defined as an XSUB or in the core.
    cwd			=> '_NT_cwd',
    getcwd		=> '_NT_cwd',
    fastcwd		=> '_NT_cwd',
    fastgetcwd		=> '_NT_cwd',
    abs_path		=> 'fast_abs_path',
    realpath		=> 'fast_abs_path',
   },
   dos => 
   {
    cwd			=> '_dos_cwd',
    getcwd		=> '_dos_cwd',
    fastgetcwd		=> '_dos_cwd',
    fastcwd		=> '_dos_cwd',
    abs_path		=> 'fast_abs_path',
   },
   qnx =>
   {
    cwd			=> '_qnx_cwd',
    getcwd		=> '_qnx_cwd',
    fastgetcwd		=> '_qnx_cwd',
    fastcwd		=> '_qnx_cwd',
    abs_path		=> '_qnx_abs_path',
    fast_abs_path	=> '_qnx_abs_path',
   },
   cygwin =>
   {
    getcwd		=> 'cwd',
    fastgetcwd		=> 'cwd',
    fastcwd		=> 'cwd',
    abs_path		=> 'fast_abs_path',
    realpath		=> 'fast_abs_path',
   },
   epoc =>
   {
    cwd			=> '_epoc_cwd',
    getcwd	        => '_epoc_cwd',
    fastgetcwd		=> '_epoc_cwd',
    fastcwd		=> '_epoc_cwd',
    abs_path		=> 'fast_abs_path',
   },
   MacOS =>
   {
    getcwd		=> 'cwd',
    fastgetcwd		=> 'cwd',
    fastcwd		=> 'cwd',
    abs_path		=> 'fast_abs_path',
   },
  );
$METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
$METHOD_MAP{nto} = $METHOD_MAP{qnx};
# Find the pwd command in the expected locations.  We assume these
# are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
# so everything works under taint mode.
my $pwd_cmd;
foreach my $try ('/bin/pwd',
		 '/usr/bin/pwd',
		 '/QOpenSys/bin/pwd', # OS/400 PASE.
		) {
    if( -x $try ) {
        $pwd_cmd = $try;
        last;
    }
my $found_pwd_cmd = defined($pwd_cmd);
unless ($pwd_cmd) {
    # Isn't this wrong?  _backtick_pwd() will fail if somenone has
    # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
    # See [perl #16774]. --jhi
    $pwd_cmd = 'pwd';
# Lazy-load Carp
sub _carp  { require Carp; Carp::carp(@_)  }
sub _croak { require Carp; Carp::croak(@_) }
# The 'natural and safe form' for UNIX (pwd may be setuid root)
sub _backtick_pwd {
    # Localize %ENV entries in a way that won't create new hash keys
    my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
    local @ENV{@localize};
    
    my $cwd = `$pwd_cmd`;
    # Belt-and-suspenders in case someone said "undef $/".
    local $/ = "\n";
    # `pwd` may fail e.g. if the disk is full
    chomp($cwd) if defined $cwd;
    $cwd;
# Since some ports may predefine cwd internally (e.g., NT)
# we take care not to override an existing definition for cwd().
unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
    # The pwd command is not available in some chroot(2)'ed environments
    my $sep = $Config::Config{path_sep} || ':';
    my $os = $^O;  # Protect $^O from tainting
    # Try again to find a pwd, this time searching the whole PATH.
    if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
	my @candidates = split($sep, $ENV{PATH});
	while (!$found_pwd_cmd and @candidates) {
	    my $candidate = shift @candidates;
	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
    }
    # MacOS has some special magic to make `pwd` work.
    if( $os eq 'MacOS' || $found_pwd_cmd )
    {
	*cwd = \&_backtick_pwd;
    }
    else {
	*cwd = \&getcwd;
    }
if ($^O eq 'cygwin') {
  # We need to make sure cwd() is called with no args, because it's
  # got an arg-less prototype and will die if args are present.
  local $^W = 0;
  my $orig_cwd = \&cwd;
  *cwd = sub { &$orig_cwd() }
# set a reasonable (and very safe) default for fastgetcwd, in case it
# isn't redefined later (20001212 rspier)
*fastgetcwd = \&cwd;
# A non-XS version of getcwd() - also used to bootstrap the perl build
# process, when miniperl is running and no XS loading happens.
sub _perl_getcwd
    abs_path('.');
# By John Bazik
# Usage: $cwd = &fastcwd;
# This is a faster version of getcwd.  It's also more dangerous because
# you might chdir out of a directory that you can't chdir back into.
    
sub fastcwd_ {
    my($odev, $oino, $cdev, $cino, $tdev, $tino);
    my(@path, $path);
    local(*DIR);
    my($orig_cdev, $orig_cino) = stat('.');
    ($cdev, $cino) = ($orig_cdev, $orig_cino);
    for (;;) {
	my $direntry;
	($odev, $oino) = ($cdev, $cino);
	CORE::chdir('..') || return undef;
	($cdev, $cino) = stat('.');
	last if $odev == $cdev && $oino == $cino;
	opendir(DIR, '.') || return undef;
	for (;;) {
	    $direntry = readdir(DIR);
	    last unless defined $direntry;
	    next if $direntry eq '.';
	    next if $direntry eq '..';
	    ($tdev, $tino) = lstat($direntry);
	    last unless $tdev != $odev || $tino != $oino;
	closedir(DIR);
	return undef unless defined $direntry; # should never happen
	unshift(@path, $direntry);
    }
    $path = '/' . join('/', @path);
    if ($^O eq 'apollo') { $path = "/".$path; }
    # At this point $path may be tainted (if tainting) and chdir would fail.
    # Untaint it then check that we landed where we started.
    $path =~ /^(.*)\z/s		# untaint
	&& CORE::chdir($1) or return undef;
    ($cdev, $cino) = stat('.');
    die "Unstable directory path, current directory changed unexpectedly"
	if $cdev != $orig_cdev || $cino != $orig_cino;
    $path;
if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
# Keeps track of current working directory in PWD environment var
# Usage:
#	use Cwd 'chdir';
#	chdir $newdir;
my $chdir_init = 0;
sub chdir_init {
    if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
	my($dd,$di) = stat('.');
	my($pd,$pi) = stat($ENV{'PWD'});
	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
	    $ENV{'PWD'} = cwd();
    }
    else {
	my $wd = cwd();
	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
	$ENV{'PWD'} = $wd;
    }
    # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
    if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
	my($pd,$pi) = stat($2);
	my($dd,$di) = stat($1);
	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
	    $ENV{'PWD'}="$2$3";
    }
    $chdir_init = 1;
sub chdir {
    my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
    $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
    chdir_init() unless $chdir_init;
    my $newpwd;
    if ($^O eq 'MSWin32') {
	# get the full path name *before* the chdir()
	$newpwd = Win32::GetFullPathName($newdir);
    }
    return 0 unless CORE::chdir $newdir;
    if ($^O eq 'VMS') {
	return $ENV{'PWD'} = $ENV{'DEFAULT'}
    }
    elsif ($^O eq 'MacOS') {
	return $ENV{'PWD'} = cwd();
    }
    elsif ($^O eq 'MSWin32') {
	$ENV{'PWD'} = $newpwd;
	return 1;
    }
    if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
	$ENV{'PWD'} = cwd();
    } elsif ($newdir =~ m#^/#s) {
	$ENV{'PWD'} = $newdir;
    } else {
	my @curdir = split(m#/#,$ENV{'PWD'});
	@curdir = ('') unless @curdir;
	my $component;
	foreach $component (split(m#/#, $newdir)) {
	    next if $component eq '.';
	    pop(@curdir),next if $component eq '..';
	    push(@curdir,$component);
	$ENV{'PWD'} = join('/',@curdir) || '/';
    }
    1;
sub _perl_abs_path
    my $start = @_ ? shift : '.';
    my($dotdots, $cwd, @pst, @cst, $dir, @tst);
    unless (@cst = stat( $start ))
    {
	_carp("stat($start): $!");
	return '';
    }
    unless (-d _) {
        # Make sure we can be invoked on plain files, not just directories.
        # NOTE that this routine assumes that '/' is the only directory separator.
        my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
	    or return cwd() . '/' . $start;
	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
	if (-l $start) {
	    my $link_target = readlink($start);
	    die "Can't resolve link $start: $!" unless defined $link_target;
	    
	    require File::Spec;
            $link_target = $dir . '/' . $link_target
                unless File::Spec->file_name_is_absolute($link_target);
	    
	    return abs_path($link_target);
	return $dir ? abs_path($dir) . "/$file" : "/$file";
    }
    $cwd = '';
    $dotdots = $start;
    do
    {
	$dotdots .= '/..';
	@pst = @cst;
	local *PARENT;
	unless (opendir(PARENT, $dotdots))
	    _carp("opendir($dotdots): $!");
	    return '';
	unless (@cst = stat($dotdots))
	    _carp("stat($dotdots): $!");
	    closedir(PARENT);
	    return '';
	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
	    $dir = undef;
	else
	    do
	    {
		unless (defined ($dir = readdir(PARENT)))
	        {
		    _carp("readdir($dotdots): $!");
		    closedir(PARENT);
		    return '';
		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
	    }
	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
		   $tst[1] != $pst[1]);
	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
	closedir(PARENT);
    } while (defined $dir);
    chop($cwd) unless $cwd eq '/'; # drop the trailing /
    $cwd;
my $Curdir;
sub fast_abs_path {
    local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
    my $cwd = getcwd();
    require File::Spec;
    my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
    # Detaint else we'll explode in taint mode.  This is safe because
    # we're not doing anything dangerous with it.
    ($path) = $path =~ /(.*)/;
    ($cwd)  = $cwd  =~ /(.*)/;
    unless (-e $path) {
 	_croak("$path: No such file or directory");
    }
    unless (-d _) {
        # Make sure we can be invoked on plain files, not just directories.
	my ($vol, $dir, $file) = File::Spec->splitpath($path);
	return File::Spec->catfile($cwd, $path) unless length $dir;
	if (-l $path) {
	    my $link_target = readlink($path);
	    die "Can't resolve link $path: $!" unless defined $link_target;
	    
	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                unless File::Spec->file_name_is_absolute($link_target);
	    
	    return fast_abs_path($link_target);
	return $dir eq File::Spec->rootdir
	  ? File::Spec->catpath($vol, $dir, $file)
	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
    }
    if (!CORE::chdir($path)) {
 	_croak("Cannot chdir to $path: $!");
    }
    my $realpath = getcwd();
    if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
 	_croak("Cannot chdir back to $cwd: $!");
    }
    $realpath;
# added function alias to follow principle of least surprise
# based on previous aliasing.  --tchrist 27-Jan-00
*fast_realpath = \&fast_abs_path;
# --- PORTING SECTION ---
# VMS: $ENV{'DEFAULT'} points to default directory at all times
# 06-Mar-1996  Charles Bailey  
bailey@newman.upenn.edu
# Note: Use of Cwd::chdir() causes the logical name PWD to be defined
#   in the process logical name table as the default device and directory
#   seen by Perl. This may not be the same as the default device
#   and directory seen by DCL after Perl exits, since the effects
#   the CRTL chdir() function persist only until Perl exits.
sub _vms_cwd {
    return $ENV{'DEFAULT'};
sub _vms_abs_path {
    return $ENV{'DEFAULT'} unless @_;
    my $path = shift;
    if (-l $path) {
        my $link_target = readlink($path);
        die "Can't resolve link $path: $!" unless defined $link_target;
	    
        return _vms_abs_path($link_target);
    }
    # may need to turn foo.dir into [.foo]
    my $pathified = VMS::Filespec::pathify($path);
    $path = $pathified if defined $pathified;
    return VMS::Filespec::rmsexpand($path);
sub _os2_cwd {
    $ENV{'PWD'} = `cmd /c cd`;
    chomp $ENV{'PWD'};
    $ENV{'PWD'} =~ s:\\:/:g ;
    return $ENV{'PWD'};
sub _win32_cwd {
    if (defined &DynaLoader::boot_DynaLoader) {
	$ENV{'PWD'} = Win32::GetCwd();
    }
    else { # miniperl
	chomp($ENV{'PWD'} = `cd`);
    }
    $ENV{'PWD'} =~ s:\\:/:g ;
    return $ENV{'PWD'};
*_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
sub _dos_cwd {
    if (!defined &Dos::GetCwd) {
        $ENV{'PWD'} = `command /c cd`;
        chomp $ENV{'PWD'};
        $ENV{'PWD'} =~ s:\\:/:g ;
    } else {
        $ENV{'PWD'} = Dos::GetCwd();
    }
    return $ENV{'PWD'};
sub _qnx_cwd {
	local $ENV{PATH} = '';
	local $ENV{CDPATH} = '';
	local $ENV{ENV} = '';
    $ENV{'PWD'} = `/usr/bin/fullpath -t`;
    chomp $ENV{'PWD'};
    return $ENV{'PWD'};
sub _qnx_abs_path {
	local $ENV{PATH} = '';
	local $ENV{CDPATH} = '';
	local $ENV{ENV} = '';
    my $path = @_ ? shift : '.';
    local *REALPATH;
    defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
      die "Can't open /usr/bin/fullpath: $!";
    my $realpath = <REALPATH>;
    close REALPATH;
    chomp $realpath;
    return $realpath;
sub _epoc_cwd {
    $ENV{'PWD'} = EPOC::getcwd();
    return $ENV{'PWD'};
# Now that all the base-level functions are set up, alias the
# user-level functions to the right places
if (exists $METHOD_MAP{$^O}) {
  my $map = $METHOD_MAP{$^O};
  foreach my $name (keys %$map) {
    local $^W = 0;  # assignments trigger 'subroutine redefined' warning
    no strict 'refs';
    *{$name} = \&{$map->{$name}};
# In case the XS version doesn't load.
*abs_path = \&_perl_abs_path unless defined &abs_path;
*getcwd = \&_perl_getcwd unless defined &getcwd;
# added function alias for those of us more
# used to the libc function.  --tchrist 27-Jan-00
*realpath = \&abs_path;
FILE
5bfeecdf/DynaLoader.pm
#line 1 "C:/Perl/lib/DynaLoader.pm"
# Generated from DynaLoader_pm.PL
package DynaLoader;
#   And Gandalf said: 'Many folk like to know beforehand what is to
#   be set on the table; but those who have laboured to prepare the
#   feast like to keep their secret; for wonder makes the words of
#   praise louder.'
#   (Quote from Tolkien suggested by Anno Siegel.)
# See pod text at end of file for documentation.
# See also ext/DynaLoader/README in source tree for other information.
# Tim.Bunce@ig.co.uk, August 1994
BEGIN {
    $VERSION = '1.0803';
    $XS_VERSION = '1.0802';
require AutoLoader;
*AUTOLOAD = \&AutoLoader::AUTOLOAD;
use Config;
# enable debug/trace messages from DynaLoader perl code
$dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;
# Flags to alter dl_load_file behaviour.  Assigned bits:
#   0x01  make symbols available for linking later dl_load_file's.
#         (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
#         (ignored under VMS; effect is built-in to image linking)
# This is called as a class method $module->dl_load_flags.  The
# definition here will be inherited and result on "default" loading
# behaviour unless a sub-class of DynaLoader defines its own version.
sub dl_load_flags { 0x00 }
($dl_dlext, $dl_so, $dlsrc) = @Config::Config{qw(dlext so dlsrc)};
$do_expand = 0;
@dl_require_symbols = ();       # names of symbols we need
@dl_resolve_using   = ();       # names of files to link with
@dl_library_path    = ();       # path to look for files
#XSLoader.pm may have added elements before we were required
#@dl_shared_objects  = ();       # shared objects for symbols we have 
#@dl_librefs         = ();       # things we have loaded
#@dl_modules         = ();       # Modules we have loaded
# This is a fix to support DLD's unfortunate desire to relink -lc
@dl_resolve_using = dl_findfile('-lc') if $dlsrc eq "dl_dld.xs";
# Initialise @dl_library_path with the 'standard' library path
# for this platform as determined by Configure.
push(@dl_library_path, split(' ', $Config::Config{libpth}));
my $ldlibpthname         = $Config::Config{ldlibpthname};
my $ldlibpthname_defined = defined $Config::Config{ldlibpthname};
my $pthsep               = $Config::Config{path_sep};
# Add to @dl_library_path any extra directories we can gather from environment
# during runtime.
if ($ldlibpthname_defined &&
    exists $ENV{$ldlibpthname}) {
    push(@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));
# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.
if ($ldlibpthname_defined &&
    $ldlibpthname ne 'LD_LIBRARY_PATH' &&
    exists $ENV{LD_LIBRARY_PATH}) {
    push(@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));
# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.
# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB
boot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&
                                !defined(&dl_error);
if ($dl_debug) {
    print STDERR "DynaLoader.pm loaded (@INC, @dl_library_path)\n";
    print STDERR "DynaLoader not linked into this perl\n"
	    unless defined(&boot_DynaLoader);
1; # End of main code
sub croak   { require Carp; Carp::croak(@_)   }
sub bootstrap_inherit {
    my $module = $_[0];
    local *isa = *{"$module\::ISA"};
    local @isa = (@isa, 'DynaLoader');
    # Cannot goto due to delocalization.  Will report errors on a wrong line?
    bootstrap(@_);
# The bootstrap function cannot be autoloaded (without complications)
# so we define it here:
sub bootstrap {
    # use local vars to enable $module.bs script to edit values
    local(@args) = @_;
    local($module) = $args[0];
    local(@dirs, $file);
    unless ($module) {
	require Carp;
	Carp::confess("Usage: DynaLoader::bootstrap(module)");
    }
    # A common error on platforms which don't support dynamic loading.
    # Since it's fatal and potentially confusing we give a detailed message.
    croak("Can't load module $module, dynamic loading not available in this perl.\n".
	"  (You may need to build a new perl executable which either supports\n".
	"  dynamic loading or has the $module module statically linked into it.)\n")
	unless defined(&dl_load_file);
    
    my @modparts = split(/::/,$module);
    my $modfname = $modparts[-1];
    # Some systems have restrictions on files names for DLL's etc.
    # mod2fname returns appropriate file base name (typically truncated)
    # It may also edit @modparts if required.
    $modfname = &mod2fname(\@modparts) if defined &mod2fname;
    
    my $modpname = join('/',@modparts);
    print STDERR "DynaLoader::bootstrap for $module ",
		       "(auto/$modpname/$modfname.$dl_dlext)\n"
	if $dl_debug;
    foreach (@INC) {
	    my $dir = "$_/auto/$modpname";
	next unless -d $dir; # skip over uninteresting directories
	# check for common cases to avoid autoload of dl_findfile
	my $try =  "$dir/$modfname.$dl_dlext";
	last if $file = (-f $try) && $try;
	# no luck here, save dir for possible later dl_findfile search
	push @dirs, $dir;
    }
    # last resort, let dl_findfile have a go in all known locations
    $file = dl_findfile(map("-L$_",@dirs,@INC), $modfname) unless $file;
    croak("Can't locate loadable object for module $module in \@INC (\@INC contains: @INC)")
	unless $file;	# wording similar to error from 'require'
    
    my $bootname = "boot_$module";
    $bootname =~ s/\W/_/g;
    @dl_require_symbols = ($bootname);
    # Execute optional '.bootstrap' perl script for this module.
    # The .bs file can be used to configure @dl_resolve_using etc to
    # match the needs of the individual module on this architecture.
    my $bs = $file;
    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    if (-s $bs) { # only read file if it's not empty
        print STDERR "BS: $bs ($^O, $dlsrc)\n" if $dl_debug;
        eval { do $bs; };
        warn "$bs: $@\n" if $@;
    }
    my $boot_symbol_ref;
    
    # Many dynamic extension loading problems will appear to come from
    # this section of code: XYZ failed at line 123 of DynaLoader.pm.
    # Often these errors are actually occurring in the initialisation
    # C code of the extension XS file. Perl reports the error as being
    # in this perl code simply because this was the last perl code
    # it executed.
    my $libref = dl_load_file($file, $module->dl_load_flags) or
	croak("Can't load '$file' for module $module: ".dl_error());
    push(@dl_librefs,$libref);  # record loaded object
    my @unresolved = dl_undef_symbols();
    if (@unresolved) {
	require Carp;
	Carp::carp("Undefined symbols present after loading $file: @unresolved\n");
    }
    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
         croak("Can't find '$bootname' symbol in $file\n");
    push(@dl_modules, $module); # record loaded module
  boot:
    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
    # See comment block above
	push(@dl_shared_objects, $file); # record files loaded
    &$xs(@args);
#sub _check_file {   # private utility to handle dl_expandspec vs -f tests
#    my($file) = @_;
#    return $file if (!$do_expand && -f $file); # the common case
#    return $file if ( $do_expand && ($file=dl_expandspec($file)));
#    return undef;
# Let autosplit and the autoloader deal with these functions:
__END__
sub dl_findfile {
    # Read ext/DynaLoader/DynaLoader.doc for detailed information.
    # This function does not automatically consider the architecture
    # or the perl library auto directories.
    my (@args) = @_;
    my (@dirs,  $dir);   # which directories to search
    my (@found);         # full paths to real files we have found
    #my $dl_ext= 'dll'; # $Config::Config{'dlext'} suffix for perl extensions
    #my $dl_so = 'dll'; # $Config::Config{'so'} suffix for shared libraries
    print STDERR "dl_findfile(@args)\n" if $dl_debug;
    # accumulate directories but process files as they appear
    arg: foreach(@args) {
        #  Special fast case: full filepath requires no search
        if (m:/: && -f $_) {
	    push(@found,$_);
	    last arg unless wantarray;
	    next;
        # Deal with directories first:
        #  Using a -L prefix is the preferred option (faster and more robust)
        if (m:^-L:) { s/^-L//; push(@dirs, $_); next; }
        #  Otherwise we try to try to spot directories by a heuristic
        #  (this is a more complicated issue than it first appears)
        if (m:/: && -d $_) {   push(@dirs, $_); next; }
        #  Only files should get this far...
        my(@names, $name);    # what filenames to look for
        if (m:-l: ) {          # convert -lname to appropriate library name
            s/-l//;
            push(@names,"lib$_.$dl_so");
            push(@names,"lib$_.a");
        } else {                # Umm, a bare name. Try various alternatives:
            # these should be ordered with the most likely first
            push(@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
            push(@names,"lib$_.$dl_so")  unless m:/:;
	    
            push(@names,"$_.a")          if !m/\.a$/ and $dlsrc eq "dl_dld.xs";
            push(@names, $_);
        }
	my $dirsep = '/';
        foreach $dir (@dirs, @dl_library_path) {
            next unless -d $dir;
	    
            foreach $name (@names) {
		my($file) = "$dir$dirsep$name";
                print STDERR " checking in $dir for $name\n" if $dl_debug;
		$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);
		#$file = _check_file($file);
		if ($file) {
                    push(@found, $file);
                    next arg; # no need to look any further
                }
            }
        }
    }
    if ($dl_debug) {
        foreach(@dirs) {
            print STDERR " dl_findfile ignored non-existent directory: $_\n" unless -d $_;
        }
        print STDERR "dl_findfile found: @found\n";
    }
    return $found[0] unless wantarray;
    @found;
sub dl_expandspec {
    my($spec) = @_;
    # Optional function invoked if DynaLoader.pm sets $do_expand.
    # Most systems do not require or use this function.
    # Some systems may implement it in the dl_*.xs file in which case
    # this autoload version will not be called but is harmless.
    # This function is designed to deal with systems which treat some
    # 'filenames' in a special way. For example VMS 'Logical Names'
    # (something like unix environment variables - but different).
    # This function should recognise such names and expand them into
    # full file paths.
    # Must return undef if $spec is invalid or file does not exist.
    my $file = $spec; # default output to input
    
	return undef unless -f $file;
    
    print STDERR "dl_expandspec($spec) => $file\n" if $dl_debug;
    $file;
sub dl_find_symbol_anywhere
    my $sym = shift;
    my $libref;
    foreach $libref (@dl_librefs) {
	my $symref = dl_find_symbol($libref,$sym);
	return $symref if $symref;
    }
    return undef;
#line 775
FILE
67f6ea16/Errno.pm
{#line 1 "C:/Perl/lib/Errno.pm"
# This file is auto-generated. ***ANY*** changes here will be lost
package Errno;
our (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);
use Exporter ();
use Config;
use strict;
"$Config{'archname'}-$Config{'osvers'}" eq
"MSWin32-x86-multi-thread-5.00"]





[unalloc_21_270336_129388032, ok, eof
    # <0 - not ok
    
    my $self = shift ;
    return G_EOF if *$self->{Closed} ;
    #return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
    return G_EOF if *$self->{EndStream} ;
    my $buffer = shift ;
    my $scan_mode = shift ;
    if (*$self->{Plain}) {
        my $tmp_buff ;
        my $len = $self->smartRead(\$tmp_buff, *$self->{BlockSize}) ;
        
        return $self->saveErrorString(G_ERR, "Error reading data: $!", $!) 
                if $len < 0 ;
        if ($len == 0 ) {
            *$self->{EndStream} = 1 ;
        }
        else {
            *$self->{PlainBytesRead} += $len ;
            $$buffer .= $tmp_buff;
        }
        return $len ;
    }
    if (*$self->{NewStream}) {
        $self->gotoNextStream() > 0
            or return G_ERR;
        # For the headers that actually uncompressed data, put the
        # uncompressed data into the output buffer.
        $$buffer .=  *$self->{Pending} ;
        my $len = length  *$self->{Pending} ;
        *$self->{Pending} = '';
        return $len; 
    }
    my $temp_buf = '';
    my $outSize = 0;
    my $status = $self->readBlock(\$temp_buf, *$self->{BlockSize}, $outSize) ;
    return G_ERR
        if $status == STATUS_ERROR  ;
    my $buf_len = 0;
    if ($status == STATUS_OK) {
        my $beforeC_len = length $temp_buf;
        my $before_len = defined $$buffer ? length $$buffer : 0 ;
        $status = *$self->{Uncomp}->uncompr(\$temp_buf, $buffer,
                                    defined *$self->{CompressedInputLengthDone} ||
                                                $self->smartEof(), $outSize);
        return $self->saveErrorString(G_ERR, *$self->{Uncomp}{Error}, *$self->{Uncomp}{ErrorNo})
            if $self->saveStatus($status) == STATUS_ERROR;
        $self->postBlockChk($buffer, $before_len) == STATUS_OK
            or return G_ERR;
        $buf_len = length($$buffer) - $before_len;
    
        *$self->{CompSize}->add($beforeC_len - length $temp_buf) ;
        *$self->{InflatedBytesRead} += $buf_len ;
        *$self->{TotalInflatedBytesRead} += $buf_len ;
        *$self->{UnCompSize}->add($buf_len) ;
        $self->filterUncompressed($buffer);
        if (*$self->{Encoding}) {
            $$buffer = *$self->{Encoding}->decode($$buffer);
        }
    }
    if ($status == STATUS_ENDSTREAM) {
        *$self->{EndStream} = 1 ;
        $self->pushBack($temp_buf)  ;
        $temp_buf = '';
        my $trailer;
        my $trailer_size = *$self->{Info}{TrailerLength} ;
        my $got = 0;
        if (*$self->{Info}{TrailerLength})
        {
            $got = $self->smartRead(\$trailer, $trailer_size) ;
        }
        if ($got == $trailer_size) {
            $self->chkTrailer($trailer) == STATUS_OK
                or return G_ERR;
        }
        else {
            return $self->TrailerError("trailer truncated. Expected " . 
                                      "$trailer_size bytes, got $got")
                if *$self->{Strict};
            $self->pushBack($trailer)  ;
        }
        # TODO - if want to file file pointer, do it here
        if (! $self->smartEof()) {
            *$self->{NewStream} = 1 ;
            if (*$self->{MultiStream}) {
                *$self->{EndStream} = 0 ;
                return $buf_len ;
            }
        }
    }
    
    # return the number of uncompressed bytes read
    return $buf_len ;
sub reset
    my $self = shift ;
    return *$self->{Uncomp}->reset();
sub filterUncompressed
#sub isEndStream
#    my $self = shift ;
#    return *$self->{NewStream} ||
#           *$self->{EndStream} ;
sub nextStream
    my $self = shift ;
    my $status = $self->gotoNextStream();
    $status == 1
        or return $status ;
    *$self->{TotalInflatedBytesRead} = 0 ;
    *$self->{LineNo} = $. = 0;
    return 1;
sub gotoNextStream
    my $self = shift ;
    if (! *$self->{NewStream}) {
        my $status = 1;
        my $buffer ;
        # TODO - make this more efficient if know the offset for the end of
        # the stream and seekable
        $status = $self->read($buffer) 
            while $status > 0 ;
        return $status
            if $status < 0;
    }
    *$self->{NewStream} = 0 ;
    *$self->{EndStream} = 0 ;
    $self->reset();
    *$self->{UnCompSize}->reset();
    *$self->{CompSize}->reset();
    my $magic = $self->ckMagic();
    #*$self->{EndStream} = 0 ;
    if ( ! $magic) {
        if (! *$self->{Transparent} )
        {
            *$self->{EndStream} = 1 ;
            return 0;
        }
        $self->clearError();
        *$self->{Type} = 'plain';
        *$self->{Plain} = 1;
        $self->pushBack(*$self->{HeaderPending})  ;
    }
    else
    {
        *$self->{Info} = $self->readHeader($magic);
        if ( ! defined *$self->{Info} ) {
            *$self->{EndStream} = 1 ;
            return -1;
        }
    }
    push @{ *$self->{InfoList} }, *$self->{Info} ;
    return 1; 
sub streamCount
    my $self = shift ;
    return 1 if ! defined *$self->{InfoList};
    return scalar @{ *$self->{InfoList} }  ;
sub read
    # return codes
    # >0 - ok, number of bytes read
    # =0 - ok, eof
    # <0 - not ok
    
    my $self = shift ;
    return G_EOF if *$self->{Closed} ;
    my $buffer ;
    if (ref $_[0] ) {
        $self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
            if readonly(${ $_[0] });
        $self->croakError(*$self->{ClassName} . "::read: not a scalar reference $_[0]" )
            unless ref $_[0] eq 'SCALAR' ;
        $buffer = $_[0] ;
    }
    else {
        $self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
            if readonly($_[0]);
        $buffer = \$_[0] ;
    }
    my $length = $_[1] ;
    my $offset = $_[2] || 0;
    if (! *$self->{AppendOutput}) {
        if (! $offset) {    
            $$buffer = '' ;
        }
        else {
            if ($offset > length($$buffer)) {
                $$buffer .= "\x00" x ($offset - length($$buffer));
            }
            else {
                substr($$buffer, $offset) = '';
            }
        }
    }
    return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
    # the core read will return 0 if asked for 0 bytes
    return 0 if defined $length && $length == 0 ;
    $length = $length || 0;
    $self->croakError(*$self->{ClassName} . "::read: length parameter is negative")
        if $length < 0 ;
    # Short-circuit if this is a simple read, with no length
    # or offset specified.
    unless ( $length || $offset) {
        if (length *$self->{Pending}) {
            $$buffer .= *$self->{Pending} ;
            my $len = length *$self->{Pending};
            *$self->{Pending} = '' ;
            return $len ;
        }
        else {
            my $len = 0;
            $len = $self->_raw_read($buffer) 
                while ! *$self->{EndStream} && $len == 0 ;
            return $len ;
        }
    }
    # Need to jump through more hoops - either length or offset 
    # or both are specified.
    my $out_buffer = *$self->{Pending} ;
    while (! *$self->{EndStream} && length($out_buffer) < $length)
    {
        my $buf_len = $self->_raw_read(\$out_buffer);
        return $buf_len 
            if $buf_len < 0 ;
    }
    $length = length $out_buffer 
        if length($out_buffer) < $length ;
    return 0 
        if $length == 0 ;
    $$buffer = '' 
        if ! defined $$buffer;
    $offset = length $$buffer
        if *$self->{AppendOutput} ;
    *$self->{Pending} = $out_buffer;
    $out_buffer = \*$self->{Pending} ;
    #substr($$buffer, $offset) = substr($$out_buffer, 0, $length, '') ;
    substr($$buffer, $offset) = substr($$out_buffer, 0, $length) ;
    substr($$out_buffer, 0, $length) =  '' ;
    return $length ;
sub _getline
    my $self = shift ;
    # Slurp Mode
    if ( ! defined $/ ) {
        my $data ;
        1 while $self->read($data) > 0 ;
        return \$data ;
    }
    # Record Mode
    if ( ref $/ eq 'SCALAR' && ${$/} =~ /^\d+$/ && ${$/} > 0) {
        my $reclen = ${$/} ;
        my $data ;
        $self->read($data, $reclen) ;
        return \$data ;
    }
    # Paragraph Mode
    if ( ! length $/ ) {
        my $paragraph ;    
        while ($self->read($paragraph) > 0 ) {
            if ($paragraph =~ s/^(.*?\n\n+)//s) {
                *$self->{Pending}  = $paragraph ;
                my $par = $1 ;
                return \$par ;
            }
        }
        return \$paragraph;
    }
    # $/ isn't empty, or a reference, so it's Line Mode.
    {
        my $line ;    
        my $offset;
        my $p = \*$self->{Pending}  ;
        if (length(*$self->{Pending}) && 
                    ($offset = index(*$self->{Pending}, $/)) >=0) {
            my $l = substr(*$self->{Pending}, 0, $offset + length $/ );
            substr(*$self->{Pending}, 0, $offset + length $/) = '';    
            return \$l;
        }
        while ($self->read($line) > 0 ) {
            my $offset = index($line, $/);
            if ($offset >= 0) {
                my $l = substr($line, 0, $offset + length $/ );
                substr($line, 0, $offset + length $/) = '';    
                $$p = $line;
                return \$l;
            }
        }
        return \$line;
    }
sub getline
    my $self = shift;
    my $current_append = *$self->{AppendOutput} ;
    *$self->{AppendOutput} = 1;
    my $lineref = $self->_getline();
    $. = ++ *$self->{LineNo} if defined $$lineref ;
    *$self->{AppendOutput} = $current_append;
    return $$lineref ;
sub getlines
    my $self = shift;
    $self->croakError(*$self->{ClassName} . 
            "::getlines: called in scalar context\n") unless wantarray;
    my($line, @lines);
    push(@lines, $line) 
        while defined($line = $self->getline);
    return @lines;
sub READLINE
    goto &getlines if wantarray;
    goto &getline;
sub getc
    my $self = shift;
    my $buf;
    return $buf if $self->read($buf, 1);
    return undef;
sub ungetc
    my $self = shift;
    *$self->{Pending} = ""  unless defined *$self->{Pending} ;    
    *$self->{Pending} = $_[0] . *$self->{Pending} ;    
sub trailingData
    my $self = shift ;
    if (defined *$self->{FH} || defined *$self->{InputEvent} ) {
        return *$self->{Prime} ;
    }
    else {
        my $buf = *$self->{Buffer} ;
        my $offset = *$self->{BufferOffset} ;
        return substr($$buf, $offset) ;
    }
sub eof
    my $self = shift ;
    return (*$self->{Closed} ||
              (!length *$self->{Pending} 
                && ( $self->smartEof() || *$self->{EndStream}))) ;
sub tell
    my $self = shift ;
    my $in ;
    if (*$self->{Plain}) {
        $in = *$self->{PlainBytesRead} ;
    }
    else {
        $in = *$self->{TotalInflatedBytesRead} ;
    }
    my $pending = length *$self->{Pending} ;
    return 0 if $pending > $in ;
    return $in - $pending ;
sub close
    # todo - what to do if close is called before the end of the gzip file
    #        do we remember any trailing data?
    my $self = shift ;
    return 1 if *$self->{Closed} ;
    untie *$self 
        if $] >= 5.008 ;
    my $status = 1 ;
    if (defined *$self->{FH}) {
        if ((! *$self->{Handle} || *$self->{AutoClose}) && ! *$self->{StdIO}) {
        #if ( *$self->{AutoClose}) {
            local $.; 
            $! = 0 ;
            $status = *$self->{FH}->close();
            return $self->saveErrorString(0, $!, $!)
                if !*$self->{InNew} && $self->saveStatus($!) != 0 ;
        }
        delete *$self->{FH} ;
        $! = 0 ;
    }
    *$self->{Closed} = 1 ;
    return 1;
sub DESTROY
    my $self = shift ;
    $self->close() ;
sub seek
    my $self     = shift ;
    my $position = shift;
    my $whence   = shift ;
    my $here = $self->tell() ;
    my $target = 0 ;
    if ($whence == SEEK_SET) {
        $target = $position ;
    }
    elsif ($whence == SEEK_CUR) {
        $target = $here + $position ;
    }
    elsif ($whence == SEEK_END) {
        $target = $position ;
        $self->croakError(*$self->{ClassName} . "::seek: SEEK_END not allowed") ;
    }
    else {
        $self->croakError(*$self->{ClassName} ."::seek: unknown value, $whence, for whence parameter");
    }
    # short circuit if seeking to current offset
    return 1 if $target == $here ;    
    # Outlaw any attempt to seek backwards
    $self->croakError( *$self->{ClassName} ."::seek: cannot seek backwards")
        if $target < $here ;
    # Walk the file to the new offset
    my $offset = $target - $here ;
    my $got;
    while (($got = $self->read(my $buffer, min($offset, *$self->{BlockSize})) ) > 0)
    {
        $offset -= $got;
        last if $offset == 0 ;
    }
    return $offset == 0 ? 1 : 0 ;
sub fileno
    my $self = shift ;
    return defined *$self->{FH} 
           ? fileno *$self->{FH} 
           : undef ;
sub binmode
    1;
#    my $self     = shift ;
#    return defined *$self->{FH} 
#            ? binmode *$self->{FH} 
#            : 1 ;
sub opened
    my $self     = shift ;
    return ! *$self->{Closed} ;
sub autoflush
    my $self     = shift ;
    return defined *$self->{FH} 
            ? *$self->{FH}->autoflush(@_) 
            : undef ;
sub input_line_number
    my $self = shift ;
    my $last = *$self->{LineNo};
    $. = *$self->{LineNo} = $_[1] if @_ ;
    return $last;
*BINMODE  = \&binmode;
*SEEK     = \&seek; 
*READ     = \&read;
*sysread  = \&read;
*TELL     = \&tell;
*EOF      = \&eof;
*FILENO   = \&fileno;
*CLOSE    = \&close;
sub _notAvailable
    my $name = shift ;
    #return sub { croak "$name Not Available" ; } ;
    return sub { croak "$name Not Available: File opened only for intput" ; } ;
*print    = _notAvailable('print');
*PRINT    = _notAvailable('print');
*printf   = _notAvailable('printf');
*PRINTF   = _notAvailable('printf');
*write    = _notAvailable('write');
*WRITE    = _notAvailable('write');
#*sysread  = \&read;
#*syswrite = \&_notAvailable;
package IO::Uncompress::Base ;
__END__
#line 1424FILE
 8a76cf03/IO/Uncompress/Gunzip.pm
/#line 1 "C:/Perl/lib/IO/Uncompress/Gunzip.pm"
package IO::Uncompress::Gunzip ;
require 5.004 ;
# for RFC1952
use strict ;
use warnings;
use bytes;
use IO::Uncompress::RawInflate 2.008 ;
use Compress::Raw::Zlib 2.008 qw( crc32 ) ;
use IO::Compress::Base::Common 2.008 qw(:Status createSelfTiedObject);
use IO::Compress::Gzip::Constants 2.008 ;
use IO::Compress::Zlib::Extra 2.008 ;
require Exporter ;
our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $GunzipError);
@ISA = qw( Exporter IO::Uncompress::RawInflate );
@EXPORT_OK = qw( $GunzipError gunzip );
%EXPORT_TAGS = %IO::Uncompress::RawInflate::DEFLATE_CONSTANTS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');
$GunzipError = '';
$VERSION = '2.008';
sub new
    my $class = shift ;
    $GunzipError = '';
    my $obj = createSelfTiedObject($class, \$GunzipError);
    $obj->_create(undef, 0, @_);
sub gunzip
    my $obj = createSelfTiedObject(undef, \$GunzipError);
    return $obj->_inf(@_) ;
sub getExtraParams
    use IO::Compress::Base::Common  2.008 qw(:Parse);
    return ( 'ParseExtra' => [1, 1, Parse_boolean,  0] ) ;
sub ckParams
    my $self = shift ;
    my $got = shift ;
    # gunzip always needs crc32
    $got->value('CRC32' => 1);
    return 1;
sub ckMagic
    my $self = shift;
    my $magic ;
    $self->smartReadExact(\$magic, GZIP_ID_SIZE);
    *$self->{HeaderPending} = $magic ;
    return $self->HeaderError("Minimum header size is " . 
                              GZIP_MIN_HEADER_SIZE . " bytes") 
        if length $magic != GZIP_ID_SIZE ;                                    
    return $self->HeaderError("Bad Magic")
        if ! isGzipMagic($magic) ;
    *$self->{Type} = 'rfc1952';
    return $magic ;
sub readHeader
    my $self = shift;
    my $magic = shift;
    return $self->_readGzipHeader($magic);
sub chkTrailer
    my $self = shift;
    my $trailer = shift;
    # Check CRC & ISIZE 
    my ($CRC32, $ISIZE) = unpack("V V", $trailer) ;
    *$self->{Info}{CRC32} = $CRC32;    
    *$self->{Info}{ISIZE} = $ISIZE;    
    if (*$self->{Strict}) {
        return $self->TrailerError("CRC mismatch")
            if $CRC32 != *$self->{Uncomp}->crc32() ;
        my $exp_isize = *$self->{UnCompSize}->get32bit();
        return $self->TrailerError("ISIZE mismatch. Got $ISIZE"
                                  . ", expected $exp_isize")
            if $ISIZE != $exp_isize ;
    }
    return STATUS_OK;
sub isGzipMagic
    my $buffer = shift ;
    return 0 if length $buffer < GZIP_ID_SIZE ;
    my ($id1, $id2) = unpack("C C", $buffer) ;
    return $id1 == GZIP_ID1 && $id2 == GZIP_ID2 ;
sub _readFullGzipHeader($)
    my ($self) = @_ ;
    my $magic = '' ;
    $self->smartReadExact(\$magic, GZIP_ID_SIZE);
    *$self->{HeaderPending} = $magic ;
    return $self->HeaderError("Minimum header size is " . 
                              GZIP_MIN_HEADER_SIZE . " bytes") 
        if length $magic != GZIP_ID_SIZE ;                                    
    return $self->HeaderError("Bad Magic")
        if ! isGzipMagic($magic) ;
    my $status = $self->_readGzipHeader($magic);
    delete *$self->{Transparent} if ! defined $status ;
    return $status ;
sub _readGzipHeader($)
    my ($self, $magic) = @_ ;
    my ($HeaderCRC) ;
    my ($buffer) = '' ;
    $self->smartReadExact(\$buffer, GZIP_MIN_HEADER_SIZE - GZIP_ID_SIZE)
        or return $self->HeaderError("Minimum header size is " . 
                                     GZIP_MIN_HEADER_SIZE . " bytes") ;
    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;
    # now split out the various parts
    my ($cm, $flag, $mtime, $xfl, $os) = unpack("C C V C C", $buffer) ;
    $cm == GZIP_CM_DEFLATED 
        or return $self->HeaderError("Not Deflate (CM is $cm)") ;
    # check for use of reserved bits
    return $self->HeaderError("Use of Reserved Bits in FLG field.")
        if $flag & GZIP_FLG_RESERVED ; 
    my $EXTRA ;
    my @EXTRA = () ;
    if ($flag & GZIP_FLG_FEXTRA) {
        $EXTRA = "" ;
        $self->smartReadExact(\$buffer, GZIP_FEXTRA_HEADER_SIZE) 
            or return $self->TruncatedHeader("FEXTRA Length") ;
        my ($XLEN) = unpack("v", $buffer) ;
        $self->smartReadExact(\$EXTRA, $XLEN) 
            or return $self->TruncatedHeader("FEXTRA Body");
        $keep .= $buffer . $EXTRA ;
        if ($XLEN && *$self->{'ParseExtra'}) {
            my $bad = IO::Compress::Zlib::Extra::parseRawExtra($EXTRA,
                                                \@EXTRA, 1, 1);
            return $self->HeaderError($bad)
                if defined $bad;
        }
    }
    my $origname ;
    if ($flag & GZIP_FLG_FNAME) {
        $origname = "" ;
        while (1) {
            $self->smartReadExact(\$buffer, 1) 
                or return $self->TruncatedHeader("FNAME");
            last if $buffer eq GZIP_NULL_BYTE ;
            $origname .= $buffer 
        }
        $keep .= $origname . GZIP_NULL_BYTE ;
        return $self->HeaderError("Non ISO 8859-1 Character found in Name")
            if *$self->{Strict} && $origname =~ /$GZIP_FNAME_INVALID_CHAR_RE/o ;
    }
    my $comment ;
    if ($flag & GZIP_FLG_FCOMMENT) {
        $comment = "";
        while (1) {
            $self->smartReadExact(\$buffer, 1) 
                or return $self->TruncatedHeader("FCOMMENT");
            last if $buffer eq GZIP_NULL_BYTE ;
            $comment .= $buffer 
        }
        $keep .= $comment . GZIP_NULL_BYTE ;
        return $self->HeaderError("Non ISO 8859-1 Character found in Comment")
            if *$self->{Strict} && $comment =~ /$GZIP_FCOMMENT_INVALID_CHAR_RE/o ;
    }
    if ($flag & GZIP_FLG_FHCRC) {
        $self->smartReadExact(\$buffer, GZIP_FHCRC_SIZE) 
            or return $self->TruncatedHeader("FHCRC");
        $HeaderCRC = unpack("v", $buffer) ;
        my $crc16 = crc32($keep) & 0xFF ;
        return $self->HeaderError("CRC16 mismatch.")
            if *$self->{Strict} && $crc16 != $HeaderCRC;
        $keep .= $buffer ;
    }
    # Assume compression method is deflated for xfl tests
    #if ($xfl) {
    #}
    *$self->{Type} = 'rfc1952';
    return {
        'Type'          => 'rfc1952',
        'FingerprintLength'  => 2,
        'HeaderLength'  => length $keep,
        'TrailerLength' => GZIP_TRAILER_SIZE,
        'Header'        => $keep,
        'isMinimalHeader' => $keep eq GZIP_MINIMUM_HEADER ? 1 : 0,
        'MethodID'      => $cm,
        'MethodName'    => $cm == GZIP_CM_DEFLATED ? "Deflated" : "Unknown" ,
        'TextFlag'      => $flag & GZIP_FLG_FTEXT ? 1 : 0,
        'HeaderCRCFlag' => $flag & GZIP_FLG_FHCRC ? 1 : 0,
        'NameFlag'      => $flag & GZIP_FLG_FNAME ? 1 : 0,
        'CommentFlag'   => $flag & GZIP_FLG_FCOMMENT ? 1 : 0,
        'ExtraFlag'     => $flag & GZIP_FLG_FEXTRA ? 1 : 0,
        'Name'          => $origname,
        'Comment'       => $comment,
        'Time'          => $mtime,
        'OsID'          => $os,
        'OsName'        => defined $GZIP_OS_Names{$os} 
                                 ? $GZIP_OS_Names{$os} : "Unknown",
        'HeaderCRC'     => $HeaderCRC,
        'Flags'         => $flag,
        'ExtraFlags'    => $xfl,
        'ExtraFieldRaw' => $EXTRA,
        'ExtraField'    => [ @EXTRA ],
        #'CompSize'=> $compsize,
        #'CRC32'=> $CRC32,
        #'OrigSize'=> $ISIZE,
      }
__END__
#line 1182FILE
$a0e604fc/IO/Uncompress/RawInflate.pm
#line 1 "C:/Perl/lib/IO/Uncompress/RawInflate.pm"
package IO::Uncompress::RawInflate ;
# for RFC1951
use strict ;
use warnings;
use bytes;
use Compress::Raw::Zlib  2.008 ;
use IO::Compress::Base::Common  2.008 qw(:Status createSelfTiedObject);
use IO::Uncompress::Base  2.008 ;
use IO::Uncompress::Adapter::Inflate  2.008 ;
require Exporter ;
our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $RawInflateError);
$VERSION = '2.008';
$RawInflateError = '';
@ISA    = qw( Exporter IO::Uncompress::Base );
@EXPORT_OK = qw( $RawInflateError rawinflate ) ;
%DEFLATE_CONSTANTS = ();
%EXPORT_TAGS = %IO::Uncompress::Base::EXPORT_TAGS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');
sub new
    my $class = shift ;
    my $obj = createSelfTiedObject($class, \$RawInflateError);
    $obj->_create(undef, 0, @_);
sub rawinflate
    my $obj = createSelfTiedObject(undef, \$RawInflateError);
    return $obj->_inf(@_);
sub getExtraParams
    return ();
sub ckParams
    my $self = shift ;
    my $got = shift ;
    return 1;
sub mkUncomp
    my $self = shift ;
    my $class = shift ;
    my $got = shift ;
    my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Inflate::mkUncompObject(
                                                                $got->value('CRC32'),
                                                                $got->value('ADLER32'),
                                                                $got->value('Scan'),
                                                            );
    return $self->saveErrorString(undef, $errstr, $errno)
        if ! defined $obj;
    *$self->{Uncomp} = $obj;
     my $magic = $self->ckMagic()
        or return 0;
    *$self->{Info} = $self->readHeader($magic)
        or return undef ;
    return 1;
sub ckMagic
    my $self = shift;
    return $self->_isRaw() ;
sub readHeader
    my $self = shift;
    my $magic = shift ;
    return {
        'Type'          => 'rfc1951',
        'FingerprintLength'  => 0,
        'HeaderLength'  => 0,
        'TrailerLength' => 0,
        'Header'        => ''
        };
sub chkTrailer
    return STATUS_OK ;
sub _isRaw
    my $self   = shift ;
    my $got = $self->_isRawx(@_);
    if ($got) {
        *$self->{Pending} = *$self->{HeaderPending} ;
    }
    else {
        $self->pushBack(*$self->{HeaderPending});
        *$self->{Uncomp}->reset();
    }
    *$self->{HeaderPending} = '';
    return $got ;
sub _isRawx
    my $self   = shift ;
    my $magic = shift ;
    $magic = '' unless defined $magic ;
    my $buffer = '';
    $self->smartRead(\$buffer, *$self->{BlockSize}) >= 0  
        or return $self->saveErrorString(undef, "No data to read");
    my $temp_buf = $magic . $buffer ;
    *$self->{HeaderPending} = $temp_buf ;    
    $buffer = '';
    my $status = *$self->{Uncomp}->uncompr(\$temp_buf, \$buffer, $self->smartEof()) ;
    return $self->saveErrorString(undef, *$self->{Uncomp}{Error}, STATUS_ERROR)
        if $status == STATUS_ERROR;
    #my $buf_len = *$self->{Uncomp}->uncompressedBytes();
    my $buf_len = length $buffer;
    if ($status == STATUS_ENDSTREAM) {
        if (*$self->{MultiStream} 
                    && (length $temp_buf || ! $self->smartEof())){
            *$self->{NewStream} = 1 ;
            *$self->{EndStream} = 0 ;
            $self->pushBack($temp_buf);
        }
        else {
            *$self->{EndStream} = 1 ;
            $self->pushBack($temp_buf);
        }
    }
    *$self->{HeaderPending} = $buffer ;    
    *$self->{InflatedBytesRead} = $buf_len ;    
    *$self->{TotalInflatedBytesRead} += $buf_len ;    
    *$self->{Type} = 'rfc1951';
    $self->saveStatus(STATUS_OK);
    return {
        'Type'          => 'rfc1951',
        'HeaderLength'  => 0,
        'TrailerLength' => 0,
        'Header'        => ''
        };
sub inflateSync
    my $self = shift ;
    # inflateSync is a no-op in Plain mode
    return 1
        if *$self->{Plain} ;
    return 0 if *$self->{Closed} ;
    #return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
    return 0 if ! length *$self->{Pending} && *$self->{EndStream} ;
    # Disable CRC check
    *$self->{Strict} = 0 ;
    my $status ;
    while (1)
    {
        my $temp_buf ;
        if (length *$self->{Pending} )
        {
            $temp_buf = *$self->{Pending} ;
            *$self->{Pending} = '';
        }
        else
        {
            $status = $self->smartRead(\$temp_buf, *$self->{BlockSize}) ;
            return $self->saveErrorString(0, "Error Reading Data")
                if $status < 0  ;
            if ($status == 0 ) {
                *$self->{EndStream} = 1 ;
                return $self->saveErrorString(0, "unexpected end of file", STATUS_ERROR);
            }
        }
        
        $status = *$self->{Uncomp}->sync($temp_buf) ;
        if ($status == STATUS_OK)
        {
            *$self->{Pending} .= $temp_buf ;
            return 1 ;
        }
        last unless $status == STATUS_ERROR ;
    }
    return 0;
#sub performScan
#    my $self = shift ;
#    my $status ;
#    my $end_offset = 0;
#    $status = $self->scan() 
#    #or return $self->saveErrorString(undef, "Error Scanning: $$error_ref", $self->errorNo) ;
#        or return $self->saveErrorString(G_ERR, "Error Scanning: $status")
#    $status = $self->zap($end_offset) 
#        or return $self->saveErrorString(G_ERR, "Error Zapping: $status");
#    #or return $self->saveErrorString(undef, "Error Zapping: $$error_ref", $self->errorNo) ;
#    #(*$obj->{Deflate}, $status) = $inf->createDeflate();
##    *$obj->{Header} = *$inf->{Info}{Header};
##    *$obj->{UnCompSize_32bit} = 
##        *$obj->{BytesWritten} = *$inf->{UnCompSize_32bit} ;
##    *$obj->{CompSize_32bit} = *$inf->{CompSize_32bit} ;
##    if ( $outType eq 'buffer') 
##      { substr( ${ *$self->{Buffer} }, $end_offset) = '' }
##    elsif ($outType eq 'handle' || $outType eq 'filename') {
##        *$self->{FH} = *$inf->{FH} ;
##        delete *$inf->{FH};
##        *$obj->{FH}->flush() ;
##        *$obj->{Handle} = 1 if $outType eq 'handle';
##        #seek(*$obj->{FH}, $end_offset, SEEK_SET) 
##        *$obj->{FH}->seek($end_offset, SEEK_SET) 
##            or return $obj->saveErrorString(undef, $!, $!) ;
##    }
#    
sub scan
    my $self = shift ;
    return 1 if *$self->{Closed} ;
    return 1 if !length *$self->{Pending} && *$self->{EndStream} ;
    my $buffer = '' ;
    my $len = 0;
    $len = $self->_raw_read(\$buffer, 1) 
        while ! *$self->{EndStream} && $len >= 0 ;
    #return $len if $len < 0 ? $len : 0 ;
    return $len < 0 ? 0 : 1 ;
sub zap
    my $self  = shift ;
    my $headerLength = *$self->{Info}{HeaderLength};
    my $block_offset =  $headerLength + *$self->{Uncomp}->getLastBlockOffset();
    $_[0] = $headerLength + *$self->{Uncomp}->getEndOffset();
    #printf "# End $_[0], headerlen $headerLength \n";;
    #printf "# block_offset $block_offset %x\n", $block_offset;
    my $byte ;
    ( $self->smartSeek($block_offset) &&
      $self->smartRead(\$byte, 1) ) 
        or return $self->saveErrorString(0, $!, $!); 
    #printf "#byte is %x\n", unpack('C*',$byte);
    *$self->{Uncomp}->resetLastBlockByte($byte);
    #printf "#to byte is %x\n", unpack('C*',$byte);
    ( $self->smartSeek($block_offset) && 
      $self->smartWrite($byte) )
        or return $self->saveErrorString(0, $!, $!); 
    #$self->smartSeek($end_offset, 1);
    return 1 ;
sub createDeflate
    my $self  = shift ;
    my ($def, $status) = *$self->{Uncomp}->createDeflateStream(
                                    -AppendOutput   => 1,
                                    -WindowBits => - MAX_WBITS,
                                    -CRC32      => *$self->{Params}->value('CRC32'),
                                    -ADLER32    => *$self->{Params}->value('ADLER32'),
                                );
    
    return wantarray ? ($status, $def) : $def ;                                
__END__
#line 1153FILE
7ef8284c/List/Util.pm
#line 1 "C:/Perl/lib/List/Util.pm"
# List::Util.pm
# Copyright (c) 1997-2006 Graham Barr <
gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
package List::Util;
use strict;
use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
require Exporter;
@ISA        = qw(Exporter);
@EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
$VERSION    = "1.19";
$XS_VERSION = $VERSION;
$VERSION    = eval $VERSION;
eval {
  # PERL_DL_NONLAZY must be false, or any errors in loading will just
  # cause the perl code to be tested
  local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  eval {
    require XSLoader;
    XSLoader::load('List::Util', $XS_VERSION);
    1;
  } or do {
    require DynaLoader;
    local @ISA = qw(DynaLoader);
    bootstrap List::Util $XS_VERSION;
  };
} unless $TESTING_PERL_ONLY;
# This code is only compiled if the XS did not load
# of for perl < 5.6.0
if (!defined &reduce) {
eval <<'ESQ' 
sub reduce (&@) {
  my $code = shift;
  no strict 'refs';
  return shift unless @_ > 1;
  use vars qw($a $b);
  my $caller = caller;
  local(*{$caller."::a"}) = \my $a;
  local(*{$caller."::b"}) = \my $b;
  $a = shift;
  foreach (@_) {
    $b = $_;
    $a = &{$code}();
  $a;
sub first (&@) {
  my $code = shift;
  foreach (@_) {
    return $_ if &{$code}();
  undef;
# This code is only compiled if the XS did not load
eval <<'ESQ' if !defined &sum;
use vars qw($a $b);
sub sum (@) { reduce { $a + $b } @_ }
sub min (@) { reduce { $a < $b ? $a : $b } @_ }
sub max (@) { reduce { $a > $b ? $a : $b } @_ }
sub minstr (@) { reduce { $a lt $b ? $a : $b } @_ }
sub maxstr (@) { reduce { $a gt $b ? $a : $b } @_ }
sub shuffle (@) {
  my @a=\(@_);
  my $n;
  my $i=@_;
  map {
    $n = rand($i--);
    (${$a[$n]}, $a[$n] = $a[$i])[0];
  } @_;
__END__
#line 282
FILE
182e5f1e/Scalar/Util.pm
#line 1 "C:/Perl/lib/Scalar/Util.pm"
# Scalar::Util.pm
# Copyright (c) 1997-2006 Graham Barr <
gbarr@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
package Scalar::Util;
use strict;
use vars qw(@ISA @EXPORT_OK $VERSION);
require Exporter;
require List::Util; # List::Util loads the XS
@ISA]




[unalloc_21_270336_129388032, ALIGN=LEFT><SPAN class="small">&nbsp;<B>Depart:<FONT COLOR="#CC6600">	
	Tue Aug-12-2008
	</FONT></B></SPAN></TD></TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" class="fltinv">	
	<TR><TD COLSPAN=5 HEIGHT=2></TD></TR>
	<TR VALIGN=TOP>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small">&nbsp;<B>Washington DC</B> (DCA)</SPAN>
	<BR>&nbsp;<SPAN class="small">Depart <SPAN class="small" >12:30 pm</SPAN></SPAN>
	<div class="small" style="margin-left:3px;">Terminal B</div>
	</TD>
	<TD WIDTH=20 ALIGN=CENTER VALIGN=TOP>
	<SPAN class="small">&nbsp;to&nbsp;</SPAN>
	</TD>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small"><B>Houston</B> (IAH)
	<script type="text/javascript">
	var strFltInBlkTitle1 = "Flight arrives on Tue 12-Aug"
	var strFltInBlkMsg1 = "The arrival date for this flight is not the same as the departure date."
	var strDelLinkText1="<u>0&nbsp;days</u>"
	</SCRIPT>
	<BR>Arrive <SPAN class="small" > 2:37 pm</SPAN>
	<div class="small">Terminal C</div>
	</SPAN>
	</TD>
	<TD WIDTH=60 ALIGN=LEFT style="padding-left:8px;">
	<SPAN class="small">3hr 7mn</SPAN>
	</TD>
	<TD WIDTH=103 ALIGN=LEFT STYLE="padding-left: 4px;">
	<SPAN class="small">Continental 259</SPAN>
	<SPAN class="small">
	</SPAN>
	</TD>
	</TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	<TR><TD COLSPAN=2 CLASS="small">
	&nbsp;Economy/Coach Class, Lunch, Boeing 737-700
	</TD></TR>
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	</table>
	<div class="dashed_hr"></div>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" class="fltinv">	
	<TR><TD COLSPAN=5 HEIGHT=2></TD></TR>
	<TR VALIGN=TOP>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small">&nbsp;<B>Houston</B> (IAH)</SPAN>
	<BR>&nbsp;<SPAN class="small">Depart <SPAN class="small" > 4:15 pm</SPAN></SPAN>
	<div class="small" style="margin-left:3px;">Terminal E</div>
	</TD>
	<TD WIDTH=20 ALIGN=CENTER VALIGN=TOP>
	<SPAN class="small">&nbsp;to&nbsp;</SPAN>
	</TD>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small"><B>Liberia</B> (LIR)
	<script type="text/javascript">
	var strFltInBlkTitle2 = "Flight arrives on Tue 12-Aug"
	var strFltInBlkMsg2 = "The arrival date for this flight is not the same as the departure date."
	var strDelLinkText2="<u>0&nbsp;days</u>"
	</SCRIPT>
	<BR>Arrive <SPAN class="small" > 6:53 pm</SPAN>
	</SPAN>
	</TD>
	<TD WIDTH=60 ALIGN=LEFT style="padding-left:8px;">
	<SPAN class="small">3hr 38mn</SPAN>
	</TD>
	<TD WIDTH=103 ALIGN=LEFT STYLE="padding-left: 4px;">
	<SPAN class="small">Continental 745</SPAN>
	<SPAN class="small">
	</SPAN>
	</TD>
	</TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	<TR><TD COLSPAN=2 CLASS="small">
	&nbsp;Economy/Coach Class, Dinner, Boeing 737-300
	</TD></TR>
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR>
	<TD VALIGN=TOP ALIGN=LEFT CLASS="small">
	&nbsp;Total distance: 2,671 mi (4,299 km)
	</TD>
	<TD VALIGN=TOP ALIGN=LEFT CLASS="small" style="padding-left:0px;width:220px;">
	Total duration: 6hr 45mn
	(8hr 23mn with connections)
	&nbsp;
	</TD>
	</TR>
	<TR><TD COLSPAN=2 HEIGHT=6></TD></TR>
	</table>
	<hr></hr>
	<table cellspacing="0" cellpadding="0" border="0">	
	<TR><TD HEIGHT=4></TD></TR>
	<TR><TD ALIGN=LEFT><SPAN class="small">&nbsp;<B>Return:<FONT COLOR="#CC6600">	
	Fri Dec-12-2008
	</FONT></B></SPAN></TD></TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" class="fltinv">	
	<TR><TD COLSPAN=5 HEIGHT=2></TD></TR>
	<TR VALIGN=TOP>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small">&nbsp;<B>Liberia</B> (LIR)</SPAN>
	<BR>&nbsp;<SPAN class="small">Depart <SPAN class="small" > 8:10 am</SPAN></SPAN>
	</TD>
	<TD WIDTH=20 ALIGN=CENTER VALIGN=TOP>
	<SPAN class="small">&nbsp;to&nbsp;</SPAN>
	</TD>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small"><B>Houston</B> (IAH)
	<script type="text/javascript">
	var strFltInBlkTitle3 = "Flight arrives on Fri 12-Dec"
	var strFltInBlkMsg3 = "The arrival date for this flight is not the same as the departure date."
	var strDelLinkText3="<u>0&nbsp;days</u>"
	</SCRIPT>
	<BR>Arrive <SPAN class="small" >11:43 am</SPAN>
	<div class="small">Terminal E</div>
	</SPAN>
	</TD>
	<TD WIDTH=60 ALIGN=LEFT style="padding-left:8px;">
	<SPAN class="small">3hr 33mn</SPAN>
	</TD>
	<TD WIDTH=103 ALIGN=LEFT STYLE="padding-left: 4px;">
	<SPAN class="small">Continental 846</SPAN>
	<SPAN class="small">
	</SPAN>
	</TD>
	</TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	<TR><TD COLSPAN=2 CLASS="small">
	&nbsp;Economy/Coach Class, Breakfast, Boeing 737-700
	</TD></TR>
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	</table>
	<div class="dashed_hr"></div>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" class="fltinv">	
	<TR><TD COLSPAN=5 HEIGHT=2></TD></TR>
	<TR VALIGN=TOP>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small">&nbsp;<B>Houston</B> (IAH)</SPAN>
	<BR>&nbsp;<SPAN class="small">Depart <SPAN class="small" > 1:00 pm</SPAN></SPAN>
	<div class="small" style="margin-left:3px;">Terminal C</div>
	</TD>
	<TD WIDTH=20 ALIGN=CENTER VALIGN=TOP>
	<SPAN class="small">&nbsp;to&nbsp;</SPAN>
	</TD>
	<TD WIDTH=120 ALIGN=LEFT VALIGN=TOP>
	<SPAN class="small"><B>Washington DC</B> (DCA)
	<script type="text/javascript">
	var strFltInBlkTitle4 = "Flight arrives on Fri 12-Dec"
	var strFltInBlkMsg4 = "The arrival date for this flight is not the same as the departure date."
	var strDelLinkText4="<u>0&nbsp;days</u>"
	</SCRIPT>
	<BR>Arrive <SPAN class="small" > 4:57 pm</SPAN>
	<div class="small">Terminal B</div>
	</SPAN>
	</TD>
	<TD WIDTH=60 ALIGN=LEFT style="padding-left:8px;">
	<SPAN class="small">2hr 57mn</SPAN>
	</TD>
	<TD WIDTH=103 ALIGN=LEFT STYLE="padding-left: 4px;">
	<SPAN class="small">Continental 458</SPAN>
	<SPAN class="small">
	</SPAN>
	</TD>
	</TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	<TR><TD COLSPAN=2 CLASS="small">
	&nbsp;Economy/Coach Class, Lunch, Boeing 737-800
	</TD></TR>
	<TR><TD COLSPAN=2 HEIGHT=4></TD></TR>
	</table>
	<table cellspacing="0" cellpadding="0" border="0" width="100%" style="color:#808080;">
	<TR>
	<TD VALIGN=TOP ALIGN=LEFT CLASS="small">
	&nbsp;Total distance: 2,671 mi (4,299 km)
	</TD>
	<TD VALIGN=TOP ALIGN=LEFT CLASS="small" style="padding-left:0px;width:220px;">
	Total duration: 6hr 30mn
	(7hr 47mn with connections)
	&nbsp;
	</TD>
	</TR>
	<TR><TD COLSPAN=2 HEIGHT=6></TD></TR>
	</table>
	</div>
	</div>
 </div>
 <div id="s_bot_closed"><p onclick="swOC();RegisterClick(-54368);">Open to see more trip details</p></div>
 <div id="s_bot_opened"><p onclick="swOC();RegisterClick(-54357);">Hide trip details</p></div>
	<comment id=THCKOPath value="Flight"></comment> 
</div>
	<div style="margin-top:24px;">
	<TABLE WIDTH=100% BORDER=0 CELLSPACING=0>
	<TR><TD ALIGN = RIGHT><!-- v1.1.3033.33114 /html.cms/TPID=1&LOCATION=ITINERARY&SUBLOCATION=CONFIRMATION&PLACEMENT=TELESNIPE&ORIG=WAS&EAPID=0&LANGID=1033&USERTYPE=SHOPPER&EMAIL=YES&secure=1&tile=0ca7220c-2ed5-4e58-b019-e9daffe2fc40 --><img src=" https://media.expedia.com/media/content/expus/graphics/launch/deals/checkout_264x64.gif">
<comment type="id" value="144866" ><!-- --></comment></TD></TR>
	</TABLE>
</div>
	<div style="margin-top:24px;margin-right:4px;">
	<style type="text/css">
	#dvPIMrpts {border: 1px solid #D6E0EB; border-top: none;font-size:12px;padding-bottom: 8px;margin-bottom: 24px;}
	#dvPIMrpts .secHeading { background-color: #FFEFBD; padding:4px 16px 10px; margin: 0px;vertical-align: middle;margin-bottom: 16px;}
	#dvPIMrpts #awdLogo {float:left;margin:0px;padding:0px;}
	#dvPIMrpts .awdCode {margin:0px;padding:0px;}
	#dvPIMrpts label {width: auto; float:none;font-size:13px;}
	#dvPIMrpts p, #dvPIMrpts div.p	{padding:0px; margin: 0px 0px 4px 138px;font-size:13px; line-height: 1.4em;}
	</style>
	<div>
	<style type="text/css">
	.rcd0 img {margin:0; padding:0; border:0; display: block;}
	.rcd0 .tdMid {background-color: #FFEFBD;border-top: 1px solid #d6e0eb;width:100%;}
	.rcd0 .tdLt img{background-color: #FFEFBD;}
	.rcd0 .tdRt img{background-color: #FFEFBD;}
	</style>
	<table class="rcd0" cellspacing="0" cellpadding="0"><tr><td class="tdLt"><img src="/eta/TY_mod_crnr_tl.gif" alt="" ></td><td class="tdMid"><img src="/eta/spaceit.gif" alt=""></td><td class="tdRt"><img src="/eta/TY_mod_crnr_tr.gif" alt=""></td></tr></table>
</div>
	<div id="dvPIMrpts">
	<h2 class="secHeading">
	ThankYou<span class="smark">
</span> Network
	</h2>
	<img src="/eta/logo_awdp.gif" id="awdLogo" alt="ThankYou" WIDTH=133 HEIGHT=43>
	<div class="awdCode">
<style type="text/css">
	#dvIHRwdPgmID #inpIHAPTS_IHLPAC_lpac	{width:130px;}
	#dvIHRwdPgmID #dvRwdPgmInp	{background-color: #EAEFF5; padding:8px 8px 8px 125px;margin: 10px 16px 8px 16px;}
	#dvIHRwdPgmID #dvRwdPgmLnk	{margin-left: 138px;}
	#dvIHRwdPgmID .show	{display:block;}
	#dvIHRwdPgmID .hidden	{display:none;}
	#dvIHRwdPgmID p, #dvIHRwdPgmID div.p	{padding:0px; margin: 0px;}
	#dvIHRwdPgmID p.bot	{padding:0px; margin: 0px;}
	#dvIHRwdPgmID .note	{margin-left:22px; margin-top: 4px;font-size:11px;}
</style>
<div id="dvIHRwdPgmID">
<input type="hidden" id="inpIHAPTS_IHLPAC_fini" name="IHAPTS_IHLPAC_fini" value="1" />
<input type="hidden" id="inpIHAPTS_IHLPAC_ihdt" name="IHAPTS_IHLPAC_ihdt" value="1" />
	<div class="bot" style="float: left;margin: 0px 16px;">
	<label for="inpIHAPTS_IHLPAC_lpac" style="color:#336699;text-align: left; font-size: 11px;">Enter your 16-digit ThankYou account number:</label>
	<div style="margin-top: 4px;"><input type="text" id="inpIHAPTS_IHLPAC_lpac" name="IHAPTS_IHLPAC_lpac" value="" maxlength="20" /><span class="smLite">&nbsp;&nbsp;(optional)</span></div>
	<div class="small" style="line-height: 2em;"><a id="lnkForgotLink" href="https://www.thankyou.com/memberlookup.jspx" target="_blank">Forgot your number?</a></div>
	</div>
	<div style="margin-top: -4px;padding: 8px; float: left; width: 338px; background-color: #fefbe9;line-height: 1.4em;">
	<b>ThankYou<span class="smark">
</span> Network is a free rewards program</b><br/>
	If you're not yet a member, you will be given the opportunity to learn more and join after you finish booking your trip.
	</div>
</div>
	</div>
	<div class="cf"></div>
	</div>
</div>
	<div style="margin-top:24px;">
<TR><TD><TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr><td>
	<style type="text/css">
	.rcd1 img {margin:0; padding:0; border:0; display: block;}
	.rcd1 .tdMid {background-color: #336699;border-top: 1px solid #336699;width:100%;}
	.rcd1 .tdLt img{background-color: #336699;}
	.rcd1 .tdRt img{background-color: #336699;}
	</style>
	<table class="rcd1" cellspacing="0" cellpadding="0"><tr><td class="tdLt"><img src="/eta/crnr_wht_tl.gif" alt="" ></td><td class="tdMid"><img src="/eta/spaceit.gif" alt=""></td><td class="tdRt"><img src="/eta/crnr_wht_tr.gif" alt=""></td></tr></table>
</td></tr>
<TR><TD><div class="secBoxBorderHeading"><b> Ticket delivery</b></div></TD></TR>
<TR><TD><div class="secBox"><table width="99%" BORDER=0 CELLSPACING=0 CELLPADDING=0>
<script type="text/javascript">
	function ETicketHelp()
	GoTo("http://www.expedia.com/pub/agent.dll?qscr=hgen&hfnm=h_fw_etix.htx&rhtx=HTX_CKO_PURCH_PREF_BDPAGE&");
</SCRIPT>
<TR><TD VALIGN=TOP>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
	<TR><TD style="padding-left:10px;">
	<B>Convenient <a ID=A5181_1001 href="javascript:ETicketHelp()">e-ticket(s)</a> will be issued for this flight.</B><br>
	When you check in for your flight, give the ticket agent your 
	government-issued photo ID, along with a copy of your Expedia itinerary or receipt.
	<INPUT TYPE=HIDDEN NAME=tkdl26_IHftkt_tcho VALUE=0>
	</TD></TR>
</TABLE>
</TD></TR>
</table></div></TD></TR>
</TABLE></TD></TR>
</div>
	<div style="margin-top:24px;">&nbsp;</div>
	<div id="divPymtNav">
	<div>
	<style type="text/css">
	.rcd2 img {margin:0; padding:0; border:0; display: block;}
	.rcd2 .tdMid {background-color: #336699;border-top: 1px solid #336699;width:100%;}
	.rcd2 .tdLt img{background-color: #336699;}
	.rcd2 .tdRt img{background-color: #336699;}
	</style>
	<table class="rcd2" cellspacing="0" cellpadding="0"><tr><td class="tdLt"><img src="/eta/crnr_wht_tl.gif" alt="" ></td><td class="tdMid"><img src="/eta/spaceit.gif" alt=""></td><td class="tdRt"><img src="/eta/crnr_wht_tr.gif" alt=""></td></tr></table>
</div>
	<div class="secBoxBorderHeading"><b>Payment information</b></div>
	</div>
	<div id="paymentSec" class="secBox2">
	<INPUT TYPE=HIDDEN NAME=chcc VALUE=1>
	<div>
	<INPUT NAME="fpty" TYPE=HIDDEN VALUE="1">
<div class="secHiLiteText">Enter&nbsp;credit card&nbsp;information</div>
<INPUT TYPE="HIDDEN" NAME="FOPIH_RgWebCC_0_IHFOPCommon_fcrf" VALUE="0">
<INPUT TYPE="HIDDEN" NAME="FOPIH_RgWebCC_0_IHFOPCommon_xppe" VALUE="-1">
<INPUT NAME="FOPIH_RgWebCC_0_bcmd" TYPE=hidden VALUE="a">
<INPUT NAME="FOPIH_RgWebCC_0_rncc" TYPE=HIDDEN VALUE="">
<INPUT NAME="FOPIH_RgWebCC_0_ccmd" TYPE=hidden VALUE="a">
<INPUT NAME="FOPIH_RgWebCC_0_cbac" TYPE=hidden VALUE="">
<INPUT NAME="FOPIH_RgWebCC_0_cbcl" TYPE=hidden VALUE="">
<script type="text/javascript">
	function LTD0()
	var d = document.ChrgIt;
	d.FOPIH_RgWebCC_0_rncc.value = 0;
	d.FOPIH_RgWebCC_0_ccmd.value = "a";
	d.FOPIH_RgWebCC_0_bcmd.value = "a";
	d.FOPIH_RgWebCC_0_cbac.value = 0;
	d.FOPIH_RgWebCC_0_cbcl.value = 0;
	function SubmitChgBillAddr0()
	LTD0();
	document.ChrgIt.FOPIH_RgWebCC_0_rncc.value = 2;
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	RFH();
	function CBAC0()
	LTD0();
	var d = document.ChrgIt;
	d.FOPIH_RgWebCC_0_cbac.value = 1;
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	SubmitChgBillAddr0();
	function CBACL0()
	LTD0();
	document.ChrgIt.FOPIH_RgWebCC_0_cbac.value = 1;
	document.ChrgIt.FOPIH_RgWebCC_0_cbcl.value = 1;
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	SubmitChgBillAddr0();
</Script>
<script type="text/javascript">
function CCSC0()
	LTD0();
	document.ChrgIt.FOPIH_RgWebCC_0_bcmd.value = ""; 
	if ( getObj("FOPIH_RgWebCC_0_cdgt") )
	document.ChrgIt.FOPIH_RgWebCC_0_cdgt.value = "";
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	RFH();
function SCC0()
	LTD0();
	document.ChrgIt.FOPIH_RgWebCC_0_rncc.value = 1;
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	RFH();
function SSC0()
	LTD0();
	document.ChrgIt.FOPIH_RgWebCC_0_rncc.value = 0;
	document.ChrgIt.FOPIH_RgWebCC_0_ccmd.value = "";
	document.ChrgIt.FOPIH_RgWebCC_0_bcmd.value = "";
	if ( getObj("FOPIH_RgWebCC_0_IHFOPCommon_fcrf") )
	document.ChrgIt.FOPIH_RgWebCC_0_IHFOPCommon_fcrf.value = 1;
	RFH();
function SubmitNewCC()
	SCC0();	
</SCRIPT>
<script type="text/javascript">
if("undefined" == typeof(g_ccinIds))
	g_ccinIds = new Array();
g_ccinIds[g_ccinIds.length] = 'FOPIH_RgWebCC_0_ccin';
</script>
<script type="text/javascript">
var cctype = new Array();
	cctype[0] = new Array();
	cctype[0][1] = 2; 
	cctype[0][2] = 1; 
	cctype[0][3] = 0; 
	cctype[0][4] = 4; 
	cctype[1] = new Array();
	cctype[1][1] = 6; 
	cctype[1][2] = 0; 
	cctype[1][3] = 0; 
	cctype[1][4] = 0; 
	cctype[2] = new Array();
	cctype[2][1] = 4; 
	cctype[2][2] = 0; 
	cctype[2][3] = 0; 
	cctype[2][4] = 3; 
	cctype[3] = new Array();
	cctype[3][1] = 3; 
	cctype[3][2] = 0; 
	cctype[3][3] = 0; 
	cctype[3][4] = 3; 
	cctype[4] = new Array();
	cctype[4][1] = 1; 
	cctype[4][2] = 0; 
	cctype[4][3] = 0; 
	cctype[4][4] = 3; 
	cctype[5] = new Array();
	cctype[5][1] = 0; 
	cctype[5][2] = 0; 
	cctype[5][3] = 0; 
	cctype[5][4] = 3; 
</SCRIPT>
<script type="text/javascript">
if("undefined" == typeof(g_cctyIds))
	g_cctyIds = new Array();
g_cctyIds[g_cctyIds.length] = 'FOPIH_RgWebCC_0_ccty';
if("undefined" == typeof(g_ccnuIds))
	g_ccnuIds = new Array();
g_ccnuIds[g_ccnuIds.length] = 'FOPIH_RgWebCC_0_ccnu';
</script>
<script type="text/javascript">
function CEM(f,c,v) 
	var d = document.ChrgIt;
	var objspan;
	eval("objspan=d.cidErrMsg"+(f));	
	if (c && objspan)
	objspan.innerHTML = "";
	eval("objspan=d.vidErrMsg"+(f));	
	if (v && objspan)
	objspan.innerHTML = "";
function CCID(ccty, f, cininame, ccinname, ccisname, ccardinput)
	// This is executed when card type is selected.
	LTD0();
	RFH();
</SCRIPT>
<script type="text/javascript">
	var szCCTTitle = "Don
t see your card type?";
	var szCCTBody = "Only forms of payment in the list above are accepted for this travel booking. Diners Club Members, please select \"Master Card\" from the Card Type dropdown list. Some forms of payment may not be available for all transactions.";
</script>
<script type="text/javascript">
	var szRCCTitle = "Why?";
	var szRCCBody = "By saving your payment card information now, you'll be able to take advantage of Express Booking services in the future. <B>Express Booking</B> is a safe and fast way to book or reserve your travel. ";
</SCRIPT>
<script type="text/javascript">
	var szDCTTitle = "Diners Club Cardmembers";
	var szDCTBody = "Diners Club recently partnered with MasterCard to increase its acceptance worldwide. If your Diners Club Card has a MasterCard logo on it, please select \"MasterCard\" from the <B>Card type</B> dropdown list.";
</SCRIPT>
<div class="ckonew small" id="CCinput">
	<span CLASS="small" style="width: 100%; padding-top: 4px;">
	</span>
<div id="CCDetails">
	<div class="ctrBlk2"><IMG SRC="/pubspec/images/mastercard.gif" alt="Master Card" > <IMG SRC="/pubspec/images/visa.gif" alt="Visa Card" >
	<IMG SRC="/pubspec/images/discover.gif" alt="Discover Card" > <IMG SRC="/pubspec/images/amex.gif" alt="American Express Card" > 
	<IMG SRC="/pubspec/images/diners_club.gif" alt="Diners Club Card"> </div>
	<div class="cf"></div>
	<label for="FOPIH_RgWebCC_0_ccty">Card type:</label>
	<SELECT class="rtBlk" style="margin-bottom: 1px;" NAME="FOPIH_RgWebCC_0_ccty" ID="FOPIH_RgWebCC_0_ccty" 
	onChange="
	CCID(this.options[this.selectedIndex].value,0,'FOPIH_RgWebCC_0_cini','FOPIH_RgWebCC_0_ccin','FOPIH_RgWebCC_0_ccis',document.all.cidprompt0);CEM(0,'','');
	<OPTION VALUE=-1 >--&nbsp;Select card type&nbsp;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<OPTION VALUE=2 
	> American Express&nbsp; 
	<OPTION VALUE=3 
	> Discover Network&nbsp; 
	<OPTION VALUE=1 
	SELECTED STYLE="color:blue;"> MasterCard&nbsp; 
	<OPTION VALUE=0 
	> Visa&nbsp; 
	</SELECT>
	<div class="cf"></div>
	<div class="ctrBlk" style="margin-bottom: 11px;">
<NOBR><A   class=small style="color:;cursor:hand" HREF="javascript:TT(szCCTTitle,szCCTBody,1,220,0,0,'',null);"><IMG SRC=/eta/tip_icon.gif style="vertical-align:middle; border: 0;margin: 0px 4px;" alt="tip" title="" WIDTH=12 HEIGHT=12>
 <script type="text/javascript">
 document.write(szCCTTitle);
	</SCRIPT>
	</NOBR></A>
	</div>
	<INPUT NAME="cidc" TYPE=HIDDEN VALUE="1">
	<label for="FOPIH_RgWebCC_0_ccnu">Card number:</label>
	<INPUT class="rtBlk" NAME="FOPIH_RgWebCC_0_ccnu" id="FOPIH_RgWebCC_0_ccnu" AUTOCOMPLETE="off" SIZE=30,1 MAXLENGTH=20 VALUE="">
	<div class="cf"></div>
	<label for="cemo">Expiration date:</label>
	<SELECT class="rtBlk" style="width:66px" id="cemo"  ID=A181_2104 NAME="FOPIH_RgWebCC_0_ccmo">
	<OPTION VALUE="">Month
	<OPTION VALUE="01" > Jan
	<OPTION VALUE="02" > Feb
	<OPTION VALUE="03" > Mar
	<OPTION VALUE="04" > Apr
	<OPTION VALUE="05" > May
	<OPTION VALUE="06" > Jun
	<OPTION VALUE="07" > Jul
	<OPTION VALUE="08" > Aug
	<OPTION VALUE="09" > Sep
	<OPTION VALUE="10" > Oct
	<OPTION VALUE="11" > Nov
	<OPTION VALUE="12" > Dec
	</SELECT>
	<SELECT class="rtBlk" style="width:66px" id="ceyy0"  ID=A181_2104 NAME="FOPIH_RgWebCC_0_ccyr">
	<OPTION VALUE="">Year
	<OPTION VALUE="2008" >2008
	<OPTION VALUE="2009" >2009
	<OPTION VALUE="2010" >2010
	<OPTION VALUE="2011" >2011
	<OPTION VALUE="2012" >2012
	<OPTION VALUE="2013" >2013
	<OPTION VALUE="2014" >2014
	<OPTION VALUE="2015" >2015
	<OPTION VALUE="2016" >2016
	<OPTION VALUE="2017" >2017
	<OPTION VALUE="2018" >2018
	<OPTION VALUE="2019" >2019
	<OPTION VALUE="2020" >2020
	<OPTION VALUE="2021" >2021
	<OPTION VALUE="2022" >2022
	<OPTION VALUE="2023" >2023
	<OPTION VALUE="2024" >2024
	<OPTION VALUE="2025" >2025
	<OPTION VALUE="2026" >2026
	<OPTION VALUE="2027" >2027
	</SELECT>
	<div class="cf"></div>	
<script type="text/javascript">
function SH(id)
	var sel = '';
	if ( (-1 == id) && ("undefined" != typeof(document.ChrgIt.FOPIH_RgWebCC_0_ccty)) )
	id = document.ChrgIt.FOPIH_RgWebCC_0_ccty.options[document.ChrgIt.FOPIH_RgWebCC_0_ccty.selectedIndex].value;
	if ( 0 == id || 1 == id )
	sel = 'visa_mc';
	else if ( 2 == id )
	sel = 'amex';
	else if ( 12 == id || 13 == id )
	sel = 'switch';
	window.open('/pub/agent.dll?qscr=hgen&page='+id+'&hfnm=h_SC_ccvernums.htx#'+sel,null,'toolbar=no,width=750,height=480,directories=no,status=no,scrollbars=yes,resizable=yes,menubar=no');
function HideCVV(value)
{	if ( 2 == value || 3 == value )
	document.getElementById('FOPIH_RgWebCC_0_ccin').style.display="none";
	else
	document.getElementById('FOPIH_RgWebCC_0_ccin').style.display="inline";
</script>
	<div class="ctrBlk" style="margin-bottom:8px">
	<div class="secSubHeadingNoBoxBD">Cardholder name&nbsp;<SPAN style="font-size:11px; font-weight:normal;" >(as it appears on the card)</SPAN></div>
	</div>
	<label for="FOPIH_RgWebCC_0_IHName_fnam">First name:</label>
	<INPUT class="rtBlk" NAME="FOPIH_RgWebCC_0_IHName_fnam" id="FOPIH_RgWebCC_0_IHName_fnam" SIZE=40,1 MAXLENGTH=15 VALUE="">
	<div class="cf"></div>
	<label for="FOPIH_RgWebCC_0_IHName_lnam">Last name:</label>
	<INPUT class="rtBlk" NAME="FOPIH_RgWebCC_0_IHName_lnam" id="FOPIH_RgWebCC_0_IHName_lnam" SIZE=40,1 MAXLENGTH=16 VALUE="">
	<div class="cf"></div>
	<div class="ctrBlk leftLink" style="margin-bottom:8px">
	</div>
	<INPUT NAME="FOPIH_RgWebCC_0_IHFOPCommon_fpkp" TYPE=HIDDEN VALUE="0">
	<SPAN id="descErrMsg0" >
	</SPAN>
	<SPAN id="ccdesc0" >
	</SPAN>
</div> 
</div>
<script type="text/javascript">
function CIDEdLoad0()
} AddLoadFn("CIDEdLoad0()");
</SCRIPT>
<div style="padding-top:16px;">
<div class="ckonew small" id="CCbilling"><div class="ctrBlk">
	<div class="secHeading">
	<div class="secSubHeadingNoBoxBD">Primary billing address</div>
	</div>
</div>
<div WIDTH=100% class="small ctrBlk">
	Please supply the cardholder's billing address as listed on the credit card statement.
</div>
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adoc" VALUE="2">
	<div class="ctrBlk">
	<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
	<TR><td ID=A259_9401_1 onclick="javascript:document.ChrgIt.FOPIH_RgWebCC_0_IHAddress_adoc.value='0';CBAC0();" CLASS=small><input type=radio id="ctryn" onmouseover="this.style.cursor='hand'" CHECKED><label for="ctryn" onmouseover="this.style.cursor='hand'" >USA</label></td><TD>&nbsp;&nbsp;&nbsp;</TD>
	<td ID=A259_9402_1 onclick="javascript:document.ChrgIt.FOPIH_RgWebCC_0_IHAddress_adoc.value='1';CBAC0();" onmouseover="this.style.cursor='hand'" CLASS=small><input type=radio id="ctryf" ><label for="ctryf">Non USA billing address</label></td>
	</TR>
	</TABLE>
	</div>
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adat" VALUE="1">
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adaf" VALUE="0">
<label for="FOPIH_RgWebCC_0_IHAddress_adcm">Company name:</label><INPUT class = "rtBlk" id="FOPIH_RgWebCC_0_IHAddress_adcm" NAME="FOPIH_RgWebCC_0_IHAddress_adcm" SIZE=30,1 MAXLENGTH=32 VALUE="" >
<span class="rtBlk smLite" style="margin-left:8px; margin-top:2px;">(optional)</span><div class="cf"></div>
	<label for="FOPIH_RgWebCC_0_IHAddress_ads1">Street:</label><INPUT class = "rtBlk" id="FOPIH_RgWebCC_0_IHAddress_ads1" NAME="FOPIH_RgWebCC_0_IHAddress_ads1" SIZE=30,1 MAXLENGTH="26" VALUE="">
	<label style="width:auto;padding-left:8px;" for="FOPIH_RgWebCC_0_IHAddress_adap">Suite or Apt:</label><INPUT class = "rtBlk" style="width:42px" id="FOPIH_RgWebCC_0_IHAddress_adap" NAME="FOPIH_RgWebCC_0_IHAddress_adap" SIZE=6,1 MAXLENGTH=5 VALUE=""> 
	<div class="cf"></div>
	<label for="FOPIH_RgWebCC_0_IHAddress_ads2" style="display: none;">Street address second line</label><INPUT class = "rtBlk" style="margin-left:155px;" id="FOPIH_RgWebCC_0_IHAddress_ads2" NAME="FOPIH_RgWebCC_0_IHAddress_ads2" SIZE=30,1 MAXLENGTH=32 VALUE="">
	<div class="cf"></div>
<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adm1" VALUE="32"> 
<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adm2" VALUE="32"> 
<label for="A181_2103">City:</label>
<INPUT class = "rtBlk"  ID=A181_2103 NAME="FOPIH_RgWebCC_0_IHAddress_adct" SIZE=30,1 MAXLENGTH=18 VALUE=""><BR></BR>
<div class="cf"></div>
<label for="A181_2104">State:</label>
<SELECT class = "rtBlk" style="width:50px; margin-top: 0px;"  ID=A181_2104 NAME="FOPIH_RgWebCC_0_IHAddress_adst" >
	<OPTION VALUE="">
	<OPTION VALUE=AL>AL
	<OPTION VALUE=AK>AK
	<OPTION VALUE=AZ>AZ
	<OPTION VALUE=AR>AR
	<OPTION VALUE=CA>CA
	<OPTION VALUE=CO>CO
	<OPTION VALUE=CT>CT
	<OPTION VALUE=DE>DE
	<OPTION VALUE=DC>DC
	<OPTION VALUE=FL>FL
	<OPTION VALUE=GA>GA
	<OPTION VALUE=HI>HI
	<OPTION VALUE=ID>ID
	<OPTION VALUE=IL>IL
	<OPTION VALUE=IN>IN
	<OPTION VALUE=IA>IA
	<OPTION VALUE=KS>KS
	<OPTION VALUE=KY>KY
	<OPTION VALUE=LA>LA
	<OPTION VALUE=ME>ME
	<OPTION VALUE=MD>MD
	<OPTION VALUE=MA>MA
	<OPTION VALUE=MI>MI
	<OPTION VALUE=MN>MN
	<OPTION VALUE=MS>MS
	<OPTION VALUE=MO>MO
	<OPTION VALUE=MT>MT
	<OPTION VALUE=NE>NE
	<OPTION VALUE=NV>NV
	<OPTION VALUE=NH>NH
	<OPTION VALUE=NJ>NJ
	<OPTION VALUE=NM>NM
	<OPTION VALUE=NY>NY
	<OPTION VALUE=NC>NC
	<OPTION VALUE=ND>ND
	<OPTION VALUE=OH>OH
	<OPTION VALUE=OK>OK
	<OPTION VALUE=OR>OR
	<OPTION VALUE=PA>PA
	<OPTION VALUE=RI>RI
	<OPTION VALUE=SC>SC
	<OPTION VALUE=SD>SD
	<OPTION VALUE=TN>TN
	<OPTION VALUE=TX>TX
	<OPTION VALUE=UT>UT
	<OPTION VALUE=VT>VT
	<OPTION VALUE=VA>VA
	<OPTION VALUE=WA>WA
	<OPTION VALUE=WV>WV
	<OPTION VALUE=WI>WI
	<OPTION VALUE=WY>WY
	<OPTION VALUE=AA>AA&nbsp;
	<OPTION VALUE=AP>AP&nbsp;
	<OPTION VALUE=AE>AE&nbsp;
</SELECT>
<label style="width:50px" for="A181_2105">Zip Code:</label>
<INPUT class = "rtBlk" style="width:80px"  ID=A181_2105 NAME="FOPIH_RgWebCC_0_IHAddress_adzp" SIZE=10,1 MAXLENGTH=10 VALUE="">
<div class="cf"></div>
<span class="ltTxt">Country: </span> <span class="rtTxt" style="margin-top:3px;width:auto;"><b>USA</b></span>&nbsp;&nbsp;
<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHAddress_adcn" VALUE="USA">
</div>	
	<div class="ckonew ctrBlk" style="padding-top: 8px;">
	<style type="text/css">
	.ckonew .ctrBlk .ltAlign {margin-left: -149px; }
	</style>
	<div class="secSubHeadingNoBoxBD">Phone number associated with this billing address</div>
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHPhone_phpf" VALUE="1">
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHPhone_phtp" VALUE="7">
	<INPUT TYPE=HIDDEN NAME="FOPIH_RgWebCC_0_IHPhone_phky" VALUE="-1">
<script type="text/javascript">
<!--
	function DispCtryBox(intLink,intBox,intText)
	intLink.style.display="none";
	intBox.style.display="block";
	intText.style.display="block";
</script>
	<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
	<TR>
	<TD>
	<DIV ID="intb0" style="display:none;padding-right:5;" class="small">
	<label for="A232_14600(1)" >
	Country:</label><BR>
	<INPUT  ID=A232_14600(1) NAME="FOPIH_RgWebCC_0_IHPhone_phct" SIZE=5,1 MAXLENGTH=3 VALUE="1">
	</DIV>
	</TD>
	<TD CLASS=small><label for="A232_14601(1)" >
	Area:</label><BR>
	<INPUT  ID=A232_14601(1) NAME="FOPIH_RgWebCC_0_IHPhone_phac" SIZE=8,1 MAXLENGTH=10 VALUE="">
	</TD>
	<TD WIDTH=5></TD>
	<TD CLASS=small><label for="A232_14602(1)" >
	Phone #:</label><BR>
	<INPUT  ID=A232_14602(1) NAME="FOPIH_RgWebCC_0_IHPhone_phnm" SIZE=15,1 MAXLENGTH=15 VALUE="">
	</TD>
	<TD WIDTH=5></TD>
	<TD CLASS=small><label for="A232_14603(1)" >
	Ext:</label><BR>
	<INPUT  ID=A232_14603(1) NAME="FOPIH_RgWebCC_0_IHPhone_phex" SIZE=5,1 MAXLENGTH=10 VALUE="">
	</TD>
	<TABLE>
	<DIV ID=intl0 style="display:block">
	<A  ID=A232_14604 href="javascript:DispCtryBox(intl0,intb0,intt0)"><FONT class=small>International number?</FONT></A>
	</DIV>
	<DIV ID=intt0 style="display:none">
	<FONT CLASS=bodyDesc CLASS=small>Tip: You can enter an international phone number. For US and Canada the country code is "1".</FONT>
	</DIV>
	</TABLE>
	</div>
</div>
<div class="secSeprtr"></div>
	</div>
	<div>
	<script type="text/javascript">
	function DEB(b)
	var emlc = getObj( 'emlc' );
	var emal = getObj( 'emal' );
	if(b)
	emlc.style.display="none";
	emal.style.display="block";
	else
	emlc.style.display="block";
	emal.style.display="none";
	function DCI_SUA(t)
	var f=ChrgIt;	
	if(!t && ""==f.emad.value)
	f.emad.value='
noemail@customercare.expedia.com';
	f.emar.value='
noemail@customercare.expedia.com';
	else if(t && "
noemail@customercare.expedia.com" == f.emad.value)
	f.emad.value="";
	f.emar.value="";
	</SCRIPT>
<div>
<div class="secHiLiteText">
	Verify the e-mail address
</div>
	<div style="line-height:22px;" class="colHead">
	All current and future correspondence, including reservation confirmations and updates, will be sent to this address.
	</div>
	<div id="emlc" style="display:none">
	<div id="acctHldr" class="rtTxt" style="width: auto;padding: 0 4px 0 2px;"><b></b></div>
	<A  ID=A280_1424 href="javascript:DEB(1)"><span>Change the e-mail address</span></A>
	<BR><BR>
	</div>
	<div class="cf"></div>
	<div id="emal" style="display:block">
	<div style="border-color:#6699CC">
	<label for="emad">Enter your e-mail address:</label>
	<INPUT TYPE=EDIT NAME=emad id="emad" SIZE=28 MAXLENGTH=128 VALUE="" class="rtBlk">
	<div class="cf"></div>
	<label for="emar">Re-enter your e-mail address:</label>
	<INPUT TYPE=EDIT NAME=emar id="emar" SIZE=28 MAXLENGTH=128 VALUE="" class="rtBlk">
	<div class="cf"></div>	
	</div>
	</div>
	<div class="ctrBlk">
	<INPUT TYPE=CHECKBOX NAME=eeoi id="eeoi" checked value="1" >
	<label for="eeoi">
E-mail me travel deals, special offers, and exclusive early access to sales.
</label>
	</div>
	<div style="padding-top:8px;" class="ctrBlk">
</div>
</div>
</div>
	<div> 
</div>
	<div class="secSeprtr"></div>
	<div class="secHiLiteText">
	<B>Choose primary purpose of your trip (optional)</B>
	</div>
	<div class="ctrBlk">
	<div>
	<INPUT onmouseover="this.style.cursor='hand'" TYPE=RADIO ID=fpos0 NAME=fpos ONCLICK="javascript:ToggleText(); RegisterClick(-54364)" VALUE=4 ><LABEL FOR="fpos0" onmouseover="this.style.cursor='hand'" style="vertical-align: 10%;font-size: 13px;" >&nbsp;Personal&nbsp;&nbsp;&nbsp;</LABEL>
	<INPUT onmouseover="this.style.cursor='hand'" TYPE=RADIO ID=fpos1 NAME=fpos ONCLICK="javascript:ToggleText(); RegisterClick(-54365)" VALUE=2 ><LABEL FOR="fpos1" onmouseover="this.style.cursor='hand'" style="vertical-align: 10%;font-size: 13px;" >&nbsp;Business</LABEL>
	</div>
	<div style="padding-top: 8px">
	<B>Note:</B> Your feedback helps us shape our services to better meet your needs. We do not sell or rent this information to anyone. For more information, read our <A HREF="/daily/service/privacy.asp">privacy policy</A>.
	</div>
	</div>
<script type="text/javascript">
<!--	
	function ToggleText()
// -->
</SCRIPT>
	</div> 
	<div class="xtraTxt">
	<div class="xtraTxt"> This total includes selected items, taxes, and service fees.  Unless specified otherwise, rates are quoted in USD.</div>
</div>
	<div class="xtraTxt">
	The total cost of your trip may be listed as separate charges on your credit card statement.
	All Expedia fees are nonrefundable.
	</div>
<style>
.TOT_regLN { border-bottom: 1px dashed #D7DCE8; }
.TOT_tfLN { border-bottom: 1px solid #D7DCE8; }
.TOT_regLN table, .TOT_tfLN]






[unalloc_21_270336_129388032, 'MemLevel'      => [1, 1, Parse_unsigned, MAX_MEM_LEVEL()],
                'Strategy'      => [1, 1, Parse_unsigned, Z_DEFAULT_STRATEGY()],
                'Dictionary'    => [1, 1, Parse_any,      ""],
                }, @_ ) ;
    croak "Compress::Zlib::deflateInit: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;
    my $obj ;
    my $status = 0 ;
    ($obj, $status) = 
      Compress::Raw::Zlib::_deflateInit(0,
                $got->value('Level'), 
                $got->value('Method'), 
                $got->value('WindowBits'), 
                $got->value('MemLevel'), 
                $got->value('Strategy'), 
                $got->value('Bufsize'),
                $got->value('Dictionary')) ;
    my $x = ($status == Z_OK() ? bless $obj, "Zlib::OldDeflate"  : undef) ;
    return wantarray ? ($x, $status) : $x ;
sub inflateInit(@)
    my ($got) = ParseParameters(0,
                {
                'Bufsize'       => [1, 1, Parse_unsigned, 4096],
                'WindowBits'    => [1, 1, Parse_signed,   MAX_WBITS()],
                'Dictionary'    => [1, 1, Parse_any,      ""],
                }, @_) ;
    croak "Compress::Zlib::inflateInit: Bufsize must be >= 1, you specified " . 
            $got->value('Bufsize')
        unless $got->value('Bufsize') >= 1;
    my $status = 0 ;
    my $obj ;
    ($obj, $status) = Compress::Raw::Zlib::_inflateInit(FLAG_CONSUME_INPUT,
                                $got->value('WindowBits'), 
                                $got->value('Bufsize'), 
                                $got->value('Dictionary')) ;
    my $x = ($status == Z_OK() ? bless $obj, "Zlib::OldInflate"  : undef) ;
    wantarray ? ($x, $status) : $x ;
package Zlib::OldDeflate ;
our (@ISA);
@ISA = qw(Compress::Raw::Zlib::deflateStream);
sub deflate
    my $self = shift ;
    my $output ;
    my $status = $self->SUPER::deflate($_[0], $output) ;
    wantarray ? ($output, $status) : $output ;
sub flush
    my $self = shift ;
    my $output ;
    my $flag = shift || Compress::Zlib::Z_FINISH();
    my $status = $self->SUPER::flush($output, $flag) ;
    
    wantarray ? ($output, $status) : $output ;
package Zlib::OldInflate ;
our (@ISA);
@ISA = qw(Compress::Raw::Zlib::inflateStream);
sub inflate
    my $self = shift ;
    my $output ;
    my $status = $self->SUPER::inflate($_[0], $output) ;
    wantarray ? ($output, $status) : $output ;
package Compress::Zlib ;
use IO::Compress::Gzip::Constants 2.008 ;
sub memGzip($)
  my $out;
  # if the deflation buffer isn't a reference, make it one
  my $string = (ref $_[0] ? $_[0] : \$_[0]) ;
  $] >= 5.008 and (utf8::downgrade($$string, 1) 
      or croak "Wide character in memGzip");
  IO::Compress::Gzip::gzip($string, \$out, Minimal => 1)
      or return undef ;
  return $out;
sub _removeGzipHeader($)
    my $string = shift ;
    return Z_DATA_ERROR() 
        if length($$string) < GZIP_MIN_HEADER_SIZE ;
    my ($magic1, $magic2, $method, $flags, $time, $xflags, $oscode) = 
        unpack ('CCCCVCC', $$string);
    return Z_DATA_ERROR()
        unless $magic1 == GZIP_ID1 and $magic2 == GZIP_ID2 and
           $method == Z_DEFLATED() and !($flags & GZIP_FLG_RESERVED) ;
    substr($$string, 0, GZIP_MIN_HEADER_SIZE) = '' ;
    # skip extra field
    if ($flags & GZIP_FLG_FEXTRA)
    {
        return Z_DATA_ERROR()
            if length($$string) < GZIP_FEXTRA_HEADER_SIZE ;
        my ($extra_len) = unpack ('v', $$string);
        $extra_len += GZIP_FEXTRA_HEADER_SIZE;
        return Z_DATA_ERROR()
            if length($$string) < $extra_len ;
        substr($$string, 0, $extra_len) = '';
    }
    # skip orig name
    if ($flags & GZIP_FLG_FNAME)
    {
        my $name_end = index ($$string, GZIP_NULL_BYTE);
        return Z_DATA_ERROR()
           if $name_end == -1 ;
        substr($$string, 0, $name_end + 1) =  '';
    }
    # skip comment
    if ($flags & GZIP_FLG_FCOMMENT)
    {
        my $comment_end = index ($$string, GZIP_NULL_BYTE);
        return Z_DATA_ERROR()
            if $comment_end == -1 ;
        substr($$string, 0, $comment_end + 1) = '';
    }
    # skip header crc
    if ($flags & GZIP_FLG_FHCRC)
    {
        return Z_DATA_ERROR()
            if length ($$string) < GZIP_FHCRC_SIZE ;
        substr($$string, 0, GZIP_FHCRC_SIZE) = '';
    }
    
    return Z_OK();
sub memGunzip($)
    # if the buffer isn't a reference, make it one
    my $string = (ref $_[0] ? $_[0] : \$_[0]);
    $] >= 5.008 and (utf8::downgrade($$string, 1) 
        or croak "Wide character in memGunzip");
    _removeGzipHeader($string) == Z_OK() 
        or return undef;
     
    my $bufsize = length $$string > 4096 ? length $$string : 4096 ;
    my $x = new Compress::Raw::Zlib::Inflate({-WindowBits => - MAX_WBITS(),
                         -Bufsize => $bufsize}) 
              or return undef;
    my $output = "" ;
    my $status = $x->inflate($string, $output);
    return undef 
        unless $status == Z_STREAM_END();
    if (length $$string >= 8)
    {
        my ($crc, $len) = unpack ("VV", substr($$string, 0, 8));
        substr($$string, 0, 8) = '';
        return undef 
            unless $len == length($output) and
                   $crc == crc32($output);
    }
    else
    {
        $$string = '';
    }
    return $output;   
# Autoload methods go after __END__, and are processed by the autosplit program.
__END__
#line 1473FILE
1789edee/Config.pm
#line 1 "C:/Perl/lib/Config.pm"
# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.
package Config;
use strict;
# use warnings; Pulls in Carp
# use vars pulls in Carp
@Config::EXPORT = qw(%Config);
@Config::EXPORT_OK = qw(myconfig config_sh config_vars config_re);
# Need to stub all the functions to make code such as print Config::config_sh
# keep working
sub myconfig;
sub config_sh;
sub config_vars;
sub config_re;
my %Export_Cache = map {($_ => 1)} (@Config::EXPORT, @Config::EXPORT_OK);
our %Config;
# Define our own import method to avoid pulling in the full Exporter:
sub import {
    my $pkg = shift;
    @_ = @Config::EXPORT unless @_;
    my @funcs = grep $_ ne '%Config', @_;
    my $export_Config = @funcs < @_ ? 1 : 0;
    no strict 'refs';
    my $callpkg = caller(0);
    foreach my $func (@funcs) {
	die sprintf qq{"%s" is not exported by the %s module\n},
	    $func, __PACKAGE__ unless $Export_Cache{$func};
	*{$callpkg.'::'.$func} = \&{$func};
    }
    *{"$callpkg\::Config"} = \%Config if $export_Config;
    return;
die "Perl lib version (5.10.0) doesn't match executable version ($])"
    unless $^V;
$^V eq 5.10.0
    or die "Perl lib version (5.10.0) doesn't match executable version (" .
	sprintf("v%vd",$^V) . ")";
sub FETCH {
    my($self, $key) = @_;
    # check for cached value (which may be undef so we use exists not defined)
    return $self->{$key} if exists $self->{$key};
    return $self->fetch_string($key);
sub TIEHASH {
    bless $_[1], $_[0];
sub DESTROY { }
sub AUTOLOAD {
    my $config_heavy = 'Config_heavy.pl';
    if (defined &ActivePerl::_CONFIG_HEAVY) {
       $config_heavy = ActivePerl::_CONFIG_HEAVY();
    }
    require $config_heavy;
    goto \&launcher unless $Config::AUTOLOAD =~ /launcher$/;
    die "&Config::AUTOLOAD failed on $Config::AUTOLOAD";
sub __unused {
    # XXX Keep PerlApp happy
    require 'Config_heavy.pl';
# tie returns the object, so the value returned to require will be true.
tie %Config, 'Config', {
    archlibexp => 'C:\Perl\\lib',
    archname => 'MSWin32-x86-multi-thread',
    d_readlink => undef,
    d_symlink => undef,
    dlext => 'dll',
    dlsrc => 'dl_win32.xs',
    dont_use_nlink => undef,
    exe_ext => '.exe',
    inc_version_list => '',
    intsize => '4',
    ldlibpthname => '',
    osname => 'MSWin32',
    osvers => '5.00',
    path_sep => ';',
    privlibexp => 'C:\Perl\\lib',
    scriptdir => 'C:\Perl\\bin',
    sitearchexp => 'C:\Perl\\site\\lib',
    sitelibexp => 'C:\Perl\\site\\lib',
    so => 'dll',
    useithreads => 'define',
    usevendorprefix => undef,
    version => '5.10.0',
FILE
e839bafb/Config_heavy.pl
sK# This file was created by configpm when Perl was built. Any changes
# made to this file will be lost the next time perl is built.
package Config;
use strict;
# use warnings; Pulls in Carp
# use vars pulls in Carp
BEGIN {
    unless ($ENV{ACTIVEPERL_CONFIG_DISABLE}) {
         eval {
             require ActivePerl::Config;
         };
         die $@ if $@ && $@ !~ /^Can't locate ActivePerl\/Config\.pm/;
    }
### Configured by: 
support@ActiveState.com
### Target system: WIN32 
our $summary = <<'!END!';
Summary of my $package (revision $revision $version_patchlevel_string) configuration:
  Platform:
    osname=$osname, osvers=$osvers, archname=$archname
    uname='$myuname'
    config_args='$config_args'
    hint=$hint, useposix=$useposix, d_sigaction=$d_sigaction
    useithreads=$useithreads, usemultiplicity=$usemultiplicity
    useperlio=$useperlio, d_sfio=$d_sfio, uselargefiles=$uselargefiles, usesocks=$usesocks
    use64bitint=$use64bitint, use64bitall=$use64bitall, uselongdouble=$uselongdouble
    usemymalloc=$usemymalloc, bincompat5005=undef
  Compiler:
    cc='$cc', ccflags ='$ccflags',
    optimize='$optimize',
    cppflags='$cppflags'
    ccversion='$ccversion', gccversion='$gccversion', gccosandvers='$gccosandvers'
    intsize=$intsize, longsize=$longsize, ptrsize=$ptrsize, doublesize=$doublesize, byteorder=$byteorder
    d_longlong=$d_longlong, longlongsize=$longlongsize, d_longdbl=$d_longdbl, longdblsize=$longdblsize
    ivtype='$ivtype', ivsize=$ivsize, nvtype='$nvtype', nvsize=$nvsize, Off_t='$lseektype', lseeksize=$lseeksize
    alignbytes=$alignbytes, prototype=$prototype
  Linker and Libraries:
    ld='$ld', ldflags ='$ldflags'
    libpth=$libpth
    libs=$libs
    perllibs=$perllibs
    libc=$libc, so=$so, useshrplib=$useshrplib, libperl=$libperl
    gnulibc_version='$gnulibc_version'
  Dynamic Linking:
    dlsrc=$dlsrc, dlext=$dlext, d_dlsymun=$d_dlsymun, ccdlflags='$ccdlflags'
    cccdlflags='$cccdlflags', lddlflags='$lddlflags'
!END!
my $summary_expanded;
sub myconfig {
    return $summary_expanded if $summary_expanded;
    ($summary_expanded = $summary) =~ s{\$(\w+)}
		 { my $c = $Config::Config{$1}; defined($c) ? $c : 'undef' }ge;
    $summary_expanded;
local *_ = \my $a;
$_ = <<'!END!';
Author=''
CONFIG='true'
Date='$Date'
Header=''
Id='$Id'
Locker=''
Log='$Log'
Mcc='Mcc'
PATCHLEVEL='10'
PERL_API_REVISION='5'
PERL_API_SUBVERSION='0'
PERL_API_VERSION='10'
PERL_CONFIG_SH='true'
PERL_PATCHLEVEL=''
PERL_REVISION='5'
PERL_SUBVERSION='0'
PERL_VERSION='10'
RCSfile='$RCSfile'
Revision='$Revision'
SUBVERSION='0'
Source=''
State=''
_a='.lib'
_exe='.exe'
_o='.obj'
afs='false'
afsroot='/afs'
alignbytes='8'
ansi2knr=''
aphostname=''
api_revision='5'
api_subversion='0'
api_version='10'
api_versionstring='5.10.0'
ar='lib'
archlib='C:\Perl\lib'
archlibexp='C:\Perl\lib'
archname64=''
archname='MSWin32-x86-multi-thread'
archobjs=''
asctime_r_proto='0'
awk='awk'
baserev='5'
bash=''
bin='C:\Perl\bin'
binexp='C:\Perl\bin'
bison=''
byacc='byacc'
byteorder='1234'
c=''
castflags='0'
cat='type'
cc='cl'
cccdlflags=' '
ccdlflags=' '
ccflags='-nologo -GF -W3 -MD -Zi -DNDEBUG -O1 -DWIN32 -D_CONSOLE -DNO_STRICT -DHAVE_DES_FCRYPT -DUSE_SITECUSTOMIZE -DPRIVLIB_LAST_IN_INC -DPERL_IMPLICIT_CONTEXT -DPERL_IMPLICIT_SYS -DUSE_PERLIO -DPERL_MSVCRT_READFIX'
ccflags_uselargefiles=''
ccname='cl'
ccsymbols=''
ccversion='12.00.8804'
cf_by='SYSTEM'
cf_email='
support@ActiveState.com'
cf_time='Tue May 13 16:52:25 2008'
chgrp=''
chmod=''
chown=''
clocktype='clock_t'
comm=''
compress=''
contains='grep'
cp='copy'
cpio=''
cpp='cl -nologo -E'
cpp_stuff='42'
cppccsymbols=''
cppflags='-DWIN32'
cpplast=''
cppminus=''
cpprun='cl -nologo -E'
cppstdin='cppstdin'
cppsymbols=''
crypt_r_proto='0'
cryptlib=''
csh='undef'
ctermid_r_proto='0'
ctime_r_proto='0'
d_Gconvert='sprintf((b),"%.*g",(n),(x))'
d_PRIEUldbl='undef'
d_PRIFUldbl='undef'
d_PRIGUldbl='undef'
d_PRIXU64='undef'
d_PRId64='undef'
d_PRIeldbl='undef'
d_PRIfldbl='undef'
d_PRIgldbl='undef'
d_PRIi64='undef'
d_PRIo64='undef'
d_PRIu64='undef'
d_PRIx64='undef'
d_SCNfldbl='undef'
d__fwalk='undef'
d_access='define'
d_accessx='undef'
d_aintl='undef'
d_alarm='define'
d_archlib='define'
d_asctime_r='undef'
d_atolf='undef'
d_atoll='undef'
d_attribute_format='undef'
d_attribute_malloc='undef'
d_attribute_nonnull='undef'
d_attribute_noreturn='undef'
d_attribute_pure='undef'
d_attribute_unused='undef'
d_attribute_warn_unused_result='undef'
d_bcmp='undef'
d_bcopy='undef'
d_bsd='define'
d_bsdgetpgrp='undef'
d_bsdsetpgrp='undef'
d_builtin_choose_expr='undef'
d_builtin_expect='undef'
d_bzero='undef'
d_c99_variadic_macros='undef'
d_casti32='undef'
d_castneg='define'
d_charvspr='undef'
d_chown='undef'
d_chroot='undef'
d_chsize='define'
d_class='undef'
d_clearenv='undef'
d_closedir='define'
d_cmsghdr_s='undef'
d_const='define'
d_copysignl='undef'
d_cplusplus='undef'
d_crypt='define'
d_crypt_r='undef'
d_csh='undef'
d_ctermid='undef'
d_ctermid_r='undef'
d_ctime_r='undef'
d_cuserid='undef'
d_dbl_dig='define'
d_dbminitproto='undef'
d_difftime='define'
d_dir_dd_fd='undef'
d_dirfd='undef'
d_dirnamlen='define'
d_dlerror='define'
d_dlopen='define'
d_dlsymun='undef'
d_dosuid='undef'
d_drand48_r='undef'
d_drand48proto='undef'
d_dup2='define'
d_eaccess='undef'
d_endgrent='undef'
d_endgrent_r='undef'
d_endhent='undef'
d_endhostent_r='undef'
d_endnent='undef'
d_endnetent_r='undef'
d_endpent='undef'
d_endprotoent_r='undef'
d_endpwent='undef'
d_endpwent_r='undef'
d_endsent='undef'
d_endservent_r='undef'
d_eofnblk='define'
d_eunice='undef'
d_faststdio='define'
d_fchdir='undef'
d_fchmod='undef'
d_fchown='undef'
d_fcntl='undef'
d_fcntl_can_lock='undef'
d_fd_macros='define'
d_fd_set='define'
d_fds_bits='define'
d_fgetpos='define'
d_finite='undef'
d_finitel='undef'
d_flexfnam='define'
d_flock='define'
d_flockproto='define'
d_fork='undef'
d_fp_class='undef'
d_fpathconf='undef'
d_fpclass='undef'
d_fpclassify='undef'
d_fpclassl='undef'
d_fpos64_t='undef'
d_frexpl='undef'
d_fs_data_s='undef'
d_fseeko='undef'
d_fsetpos='define'
d_fstatfs='undef'
d_fstatvfs='undef'
d_fsync='undef'
d_ftello='undef'
d_ftime='define'
d_futimes='undef'
d_getcwd='define'
d_getespwnam='undef'
d_getfsstat='undef'
d_getgrent='undef'
d_getgrent_r='undef'
d_getgrgid_r='undef'
d_getgrnam_r='undef'
d_getgrps='undef'
d_gethbyaddr='define'
d_gethbyname='define'
d_gethent='undef'
d_gethname='define'
d_gethostbyaddr_r='undef'
d_gethostbyname_r='undef'
d_gethostent_r='undef'
d_gethostprotos='define'
d_getitimer='undef'
d_getlogin='define'
d_getlogin_r='undef'
d_getmnt='undef'
d_getmntent='undef'
d_getnbyaddr='undef'
d_getnbyname='undef'
d_getnent='undef'
d_getnetbyaddr_r='undef'
d_getnetbyname_r='undef'
d_getnetent_r='undef'
d_getnetprotos='undef'
d_getpagsz='undef'
d_getpbyname='define'
d_getpbynumber='define'
d_getpent='undef'
d_getpgid='undef'
d_getpgrp2='undef'
d_getpgrp='undef'
d_getppid='undef'
d_getprior='undef'
d_getprotobyname_r='undef'
d_getprotobynumber_r='undef'
d_getprotoent_r='undef'
d_getprotoprotos='define'
d_getprpwnam='undef'
d_getpwent='undef'
d_getpwent_r='undef'
d_getpwnam_r='undef'
d_getpwuid_r='undef'
d_getsbyname='define'
d_getsbyport='define'
d_getsent='undef'
d_getservbyname_r='undef'
d_getservbyport_r='undef'
d_getservent_r='undef'
d_getservprotos='define'
d_getspnam='undef'
d_getspnam_r='undef'
d_gettimeod='define'
d_gmtime_r='undef'
d_gnulibc='undef'
d_grpasswd='undef'
d_hasmntopt='undef'
d_htonl='define'
d_ilogbl='undef'
d_inc_version_list='undef'
d_index='undef'
d_inetaton='undef'
d_int64_t='undef'
d_isascii='define'
d_isfinite='undef'
d_isinf='undef'
d_isnan='define'
d_isnanl='undef'
d_killpg='define'
d_lchown='undef'
d_ldbl_dig='define'
d_libm_lib_version='undef'
d_link='define'
d_localtime_r='undef'
d_localtime_r_needs_tzset='undef'
d_locconv='define'
d_lockf='undef'
d_longdbl='define'
d_longlong='undef'
d_lseekproto='define'
d_lstat='undef'
d_madvise='undef'
d_malloc_good_size='undef'
d_malloc_size='undef'
d_mblen='define'
d_mbstowcs='define'
d_mbtowc='define'
d_memchr='define'
d_memcmp='define'
d_memcpy='define'
d_memmove='define'
d_memset='define'
d_mkdir='define'
d_mkdtemp='undef'
d_mkfifo='undef'
d_mkstemp='undef'
d_mkstemps='undef'
d_mktime='define'
d_mmap='undef'
d_modfl='undef'
d_modfl_pow32_bug='undef'
d_modflproto='undef'
d_mprotect='undef'
d_msg='undef'
d_msg_ctrunc='undef'
d_msg_dontroute='undef'
d_msg_oob='undef'
d_msg_peek='undef'
d_msg_proxy='undef'
d_msgctl='undef'
d_msgget='undef'
d_msghdr_s='undef'
d_msgrcv='undef'
d_msgsnd='undef'
d_msync='undef'
d_munmap='undef'
d_mymalloc='undef'
d_nice='undef'
d_nl_langinfo='undef'
d_nv_preserves_uv='define'
d_nv_zero_is_allbits_zero='define'
d_off64_t='undef'
d_old_pthread_create_joinable='undef'
d_oldpthreads='undef'
d_oldsock='undef'
d_open3='undef'
d_pathconf='undef'
d_pause='define'
d_perl_otherlibdirs='undef'
d_phostname='undef'
d_pipe='define'
d_poll='undef'
d_portable='define'
d_printf_format_null='undef'
d_procselfexe='undef'
d_pseudofork='define'
d_pthread_atfork='undef'
d_pthread_attr_setscope='undef'
d_pthread_yield='undef'
d_pwage='undef'
d_pwchange='undef'
d_pwclass='undef'
d_pwcomment='undef'
d_pwexpire='undef'
d_pwgecos='undef'
d_pwpasswd='undef'
d_pwquota='undef'
d_qgcvt='undef'
d_quad='undef'
d_random_r='undef'
d_readdir64_r='undef'
d_readdir='define'
d_readdir_r='undef'
d_readlink='undef'
d_readv='undef'
d_recvmsg='undef'
d_rename='define'
d_rewinddir='define'
d_rmdir='define'
d_safebcpy='undef'
d_safemcpy='undef'
d_sanemcmp='define'
d_sbrkproto='undef'
d_scalbnl='undef'
d_sched_yield='undef'
d_scm_rights='undef'
d_seekdir='define'
d_select='define'
d_sem='undef'
d_semctl='undef'
d_semctl_semid_ds='undef'
d_semctl_semun='undef'
d_semget='undef'
d_semop='undef'
d_sendmsg='undef'
d_setegid='undef'
d_seteuid='undef'
d_setgrent='undef'
d_setgrent_r='undef'
d_setgrps='undef'
d_sethent='undef'
d_sethostent_r='undef'
d_setitimer='undef'
d_setlinebuf='undef'
d_setlocale='define'
d_setlocale_r='undef'
d_setnent='undef'
d_setnetent_r='undef'
d_setpent='undef'
d_setpgid='undef'
d_setpgrp2='undef'
d_setpgrp='undef'
d_setprior='undef'
d_setproctitle='undef'
d_setprotoent_r='undef'
d_setpwent='undef'
d_setpwent_r='undef'
d_setregid='undef'
d_setresgid='undef'
d_setresuid='undef'
d_setreuid='undef'
d_setrgid='undef'
d_setruid='undef'
d_setsent='undef'
d_setservent_r='undef'
d_setsid='undef'
d_setvbuf='define'
d_sfio='undef'
d_shm='undef'
d_shmat='undef'
d_shmatprototype='undef'
d_shmctl='undef'
d_shmdt='undef'
d_shmget='undef'
d_sigaction='undef'
d_signbit='undef'
d_sigprocmask='undef'
d_sigsetjmp='undef'
d_sitearch='define'
d_snprintf='define'
d_sockatmark='undef'
d_sockatmarkproto='undef'
d_socket='define'
d_socklen_t='undef'
d_sockpair='undef'
d_socks5_init='undef'
d_sprintf_returns_strlen='define'
d_sqrtl='undef'
d_srand48_r='undef'
d_srandom_r='undef'
d_sresgproto='undef'
d_sresuproto='undef'
d_statblks='undef'
d_statfs_f_flags='undef'
d_statfs_s='undef'
d_statvfs='undef'
d_stdio_cnt_lval='define'
d_stdio_ptr_lval='define'
d_stdio_ptr_lval_nochange_cnt='define'
d_stdio_ptr_lval_sets_cnt='undef'
d_stdio_stream_array='undef'
d_stdiobase='define'
d_stdstdio='define'
d_strchr='define'
d_strcoll='define'
d_strctcpy='define'
d_strerrm='strerror(e)'
d_strerror='define'
d_strerror_r='undef'
d_strftime='define'
d_strlcat='undef'
d_strlcpy='undef'
d_strtod='define'
d_strtol='define'
d_strtold='undef'
d_strtoll='undef'
d_strtoq='undef'
d_strtoul='define'
d_strtoull='undef'
d_strtouq='undef'
d_strxfrm='define'
d_suidsafe='undef'
d_symlink='undef'
d_syscall='undef'
d_syscallproto='undef'
d_sysconf='undef'
d_sysernlst=''
d_syserrlst='define'
d_system='define'
d_tcgetpgrp='undef'
d_tcsetpgrp='undef'
d_telldir='define'
d_telldirproto='define'
d_time='define'
d_times='define'
d_tm_tm_gmtoff='undef'
d_tm_tm_zone='undef'
d_tmpnam_r='undef'
d_truncate='undef'
d_ttyname_r='undef'
d_tzname='define'
d_u32align='define'
d_ualarm='undef'
d_umask='define'
d_uname='define'
d_union_semun='define'
d_unordered='undef'
d_unsetenv='undef'
d_usleep='undef'
d_usleepproto='undef'
d_ustat='undef'
d_vendorarch='undef'
d_vendorbin='undef'
d_vendorlib='undef'
d_vendorscript='undef'
d_vfork='undef'
d_void_closedir='undef'
d_voidsig='define'
d_voidtty=''
d_volatile='define'
d_vprintf='define'
d_vsnprintf='define'
d_wait4='undef'
d_waitpid='define'
d_wcstombs='define'
d_wctomb='define'
d_writev='undef'
d_xenix='undef'
date='date'
db_hashtype='int'
db_prefixtype='int'
db_version_major='0'
db_version_minor='0'
db_version_patch='0'
defvoidused='15'
direntrytype='struct direct'
dlext='dll'
dlsrc='dl_win32.xs'
doublesize='8'
drand01='(rand()/(double)((unsigned)1<<RANDBITS))'
drand48_r_proto='0'
dynamic_ext='B Compress/Raw/Zlib Cwd Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Fcntl File/Glob Filter/Util/Call Hash/Util Hash/Util/FieldHash IO List/Util MIME/Base64 Math/BigInt/FastCalc Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Text/Soundex Time/HiRes Time/Piece Unicode/Normalize Win32 Win32API/File XS/APItest XS/Typemap attrs re threads threads/shared'
eagain='EAGAIN'
ebcdic='undef'
echo='echo'
egrep='egrep'
emacs=''
endgrent_r_proto='0'
endhostent_r_proto='0'
endnetent_r_proto='0'
endprotoent_r_proto='0'
endpwent_r_proto='0'
endservent_r_proto='0'
eunicefix=':'
exe_ext='.exe'
expr='expr'
extensions='B Compress/Raw/Zlib Compress/Zlib Cwd Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Errno Fcntl File/Glob Filter/Util/Call Hash/Util Hash/Util/FieldHash IO IO_Compress_Base IO_Compress_Zlib List/Util MIME/Base64 Math/BigInt/FastCalc Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Text/Soundex Time/HiRes Time/Piece Unicode/Normalize Win32 Win32API/File Win32CORE XS/APItest XS/Typemap attrs re threads threads/shared'
extras=''
fflushNULL='define'
fflushall='undef'
find='find'
firstmakefile='makefile'
flex=''
fpossize='8'
fpostype='fpos_t'
freetype='void'
from=':'
full_ar=''
full_csh=''
full_sed=''
gccansipedantic=''
gccosandvers=''
gccversion=''
getgrent_r_proto='0'
getgrgid_r_proto='0'
getgrnam_r_proto='0'
gethostbyaddr_r_proto='0'
gethostbyname_r_proto='0'
gethostent_r_proto='0'
getlogin_r_proto='0'
getnetbyaddr_r_proto='0'
getnetbyname_r_proto='0'
getnetent_r_proto='0'
getprotobyname_r_proto='0'
getprotobynumber_r_proto='0'
getprotoent_r_proto='0'
getpwent_r_proto='0'
getpwnam_r_proto='0'
getpwuid_r_proto='0'
getservbyname_r_proto='0'
getservbyport_r_proto='0'
getservent_r_proto='0'
getspnam_r_proto='0'
gidformat='"ld"'
gidsign='-1'
gidsize='4'
gidtype='gid_t'
glibpth='/usr/shlib  /lib/pa1.1 /usr/lib/large /lib /usr/lib /usr/lib/386 /lib/386 /lib/large /usr/lib/small /lib/small /usr/ccs/lib /usr/ucblib /usr/shlib '
gmake='gmake'
gmtime_r_proto='0'
gnulibc_version=''
grep='grep'
groupcat=''
groupstype='gid_t'
gzip='gzip'
h_fcntl='false'
h_sysfile='true'
hint='recommended'
hostcat='ypcat hosts'
html1dir=' '
html1direxp=''
html3dir=' '
html3direxp=''
i16size='2'
i16type='short'
i32size='4'
i32type='long'
i64size='8'
i64type='__int64'
i8size='1'
i8type='char'
i_arpainet='define'
i_bsdioctl=''
i_crypt='undef'
i_db='undef'
i_dbm='undef'
i_dirent='define'
i_dld='undef'
i_dlfcn='define'
i_fcntl='define'
i_float='define'
i_fp='undef'
i_fp_class='undef'
i_gdbm='undef'
i_grp='undef'
i_ieeefp='undef'
i_inttypes='undef'
i_langinfo='undef'
i_libutil='undef'
i_limits='define'
i_locale='define'
i_machcthr='undef'
i_malloc='define'
i_math='define'
i_memory='undef'
i_mntent='undef'
i_ndbm='undef'
i_netdb='undef'
i_neterrno='undef'
i_netinettcp='undef'
i_niin='undef'
i_poll='undef'
i_prot='undef'
i_pthread='undef'
i_pwd='undef'
i_rpcsvcdbm='define'
i_sfio='undef'
i_sgtty='undef'
i_shadow='undef'
i_socks='undef'
i_stdarg='define'
i_stddef='define'
i_stdlib='define'
i_string='define'
i_sunmath='undef'
i_sysaccess='undef'
i_sysdir='undef'
i_sysfile='undef'
i_sysfilio='define'
i_sysin='undef'
i_sysioctl='undef'
i_syslog='undef'
i_sysmman='undef'
i_sysmode='undef'
i_sysmount='undef'
i_sysndir='undef'
i_sysparam='undef'
i_sysresrc='undef'
i_syssecrt='undef'
i_sysselct='undef'
i_syssockio='undef'
i_sysstat='define'
i_sysstatfs='undef'
i_sysstatvfs='undef'
i_systime='undef'
i_systimek='undef'
i_systimes='undef'
i_systypes='define'
i_sysuio='undef'
i_sysun='undef'
i_sysutsname='undef'
i_sysvfs='undef'
i_syswait='undef'
i_termio='undef'
i_termios='undef'
i_time='define'
i_unistd='undef'
i_ustat='undef'
i_utime='define'
i_values='undef'
i_varargs='undef'
i_varhdr='varargs.h'
i_vfork='undef'
ignore_versioned_solibs=''
inc_version_list=''
inc_version_list_init='0'
incpath='\include'
inews=''
initialinstalllocation=''
installarchlib='C:\Perl\lib'
installbin='C:\Perl\bin'
installhtml1dir=''
installhtml3dir=''
installhtmldir='C:\Perl\html'
installhtmlhelpdir='C:\Perl\htmlhelp'
installman1dir='C:\Perl\man\man1'
installman3dir='C:\Perl\man\man3'
installprefix='C:\Perl'
installprefixexp='C:\Perl'
installprivlib='C:\Perl\lib'
installscript='C:\Perl\bin'
installsitearch='C:\Perl\site\lib'
installsitebin='C:\Perl\site\bin'
installsitehtml1dir=''
installsitehtml3dir=''
installsitelib='C:\Perl\site\lib'
installsiteman1dir=''
installsiteman3dir=''
installsitescript='C:\Perl\site\bin'
installstyle='lib'
installusrbinperl='undef'
installvendorarch=''
installvendorbin=''
installvendorhtml1dir=''
installvendorhtml3dir=''
installvendorlib=''
installvendorman1dir=''
installvendorman3dir=''
installvendorscript=''
intsize='4'
issymlink=''
ivdformat='"ld"'
ivsize='4'
ivtype='long'
known_extensions='B Compress/Raw/Zlib Cwd DB_File Data/Dumper Devel/DProf Devel/PPPort Devel/Peek Digest/MD5 Digest/SHA Encode Fcntl File/Glob Filter/Util/Call GDBM_File Hash/Util Hash/Util/FieldHash I18N/Langinfo IO IPC/SysV List/Util MIME/Base64 Math/BigInt/FastCalc NDBM_File ODBM_File Opcode POSIX PerlIO/encoding PerlIO/scalar PerlIO/via SDBM_File Socket Storable Sys/Hostname Sys/Syslog Text/Soundex Time/HiRes Time/Piece Unicode/Normalize Win32 Win32API/File Win32CORE XS/APItest XS/Typemap attrs re threads threads/shared'
ksh=''
ld='link'
lddlflags='-dll -nologo -nodefaultlib -debug -opt:ref,icf  -libpath:"C:\Perl\lib\CORE"  -machine:x86'
ldflags='-nologo -nodefaultlib -debug -opt:ref,icf  -libpath:"C:\Perl\lib\CORE"  -machine:x86'
ldflags_uselargefiles=''
ldlibpthname=''
less='less'
lib_ext='.lib'
libc='msvcrt.lib'
libperl='perl510.lib'
libpth='\lib'
libs='  oldnames.lib kernel32.lib user32.lib gdi32.lib winspool.lib  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib  netapi32.lib uuid.lib ws2_32.lib mpr.lib winmm.lib  version.lib odbc32.lib odbccp32.lib msvcrt.lib'
libsdirs=''
libsfiles=''
libsfound=''
libspath=''
libswanted='net socket inet nsl nm ndbm gdbm dbm db malloc dl dld ld sun m c cposix posix ndir dir crypt ucb bsd BSD PW x'
libswanted_uselargefiles='net socket inet nsl nm ndbm gdbm dbm db malloc dl dld ld sun m c cposix posix ndir dir crypt ucb bsd BSD PW x'
line='line'
lint=''
lkflags=''
ln=''
lns='copy'
localtime_r_proto='0'
locincpth='/usr/local/include /opt/local/include /usr/gnu/include /opt/gnu/include /usr/GNU/include /opt/GNU/include'
loclibpth='/usr/local/lib /opt/local/lib /usr/gnu/lib /opt/gnu/lib /usr/GNU/lib /opt/GNU/lib'
longdblsize='10'
longlongsize='8'
longsize='4'
lp=''
lpr=''
ls='dir'
lseeksize='8'
lseektype='__int64'
mad='undef'
madlyh=''
madlyobj=''
madlysrc=''
mail=''
mailx=''
make='nmake'
make_set_make='#'
mallocobj='malloc.o'
mallocsrc='malloc.c'
malloctype='void *'
man1dir='C:\Perl\man\man1'
man1direxp='C:\Perl\man\man1'
man1ext='1'
man3dir='C:\Perl\man\man3'
man3direxp='C:\Perl\man\man3'
man3ext='3'
mips_type=''
mistrustnm=''
mkdir='mkdir'
mmaptype='void *'
modetype='mode_t'
more='more /e'
multiarch='undef'
mv=''
myarchname='MSWin32'
mydomain=''
myhostname=''
myuname=''
n='-n'
need_va_copy='undef'
netdb_hlen_type='int'
netdb_host_type='char *'
netdb_name_type='char *'
netdb_net_type='long'
nm=''
nm_opt=''
nm_so_opt=''
nonxs_ext='Compress/Zlib Errno IO_Compress_Base IO_Compress_Zlib'
nroff=''
nvEUformat='"E"'
nvFUformat='"F"'
nvGUformat='"G"'
nv_preserves_uv_bits='32'
nveformat='"e"'
nvfformat='"f"'
nvgformat='"g"'
nvsize='8'
nvtype='double'
o_nonblock='O_NONBLOCK'
obj_ext='.obj'
old_pthread_create_joinable=''
optimize='-MD -Zi -DNDEBUG -O1'
orderlib='false'
osname='MSWin32'
osvers='5.00'
otherlibdirs=''
package='perl5'
pager='more /e'
passcat=''
patchlevel='10'
path_sep=';'
perl5=''
perl='perl'
perl_patchlevel=''
perladmin=''
perllibs='  oldnames.lib kernel32.lib user32.lib gdi32.lib winspool.lib  comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib  netapi32.lib uuid.lib ws2_32.lib mpr.lib winmm.lib  version.lib odbc32.lib odbccp32.lib msvcrt.lib'
perlpath='C:\Perl\bin\perl.exe'
pg=''
phostname='hostname'
pidtype='int'
plibpth=''
pmake=''
pr=''
prefix='C:\Perl'
prefixexp='C:\Perl'
privlib='C:\Perl\lib'
privlibexp='C:\Perl\lib'
procselfexe=''
prototype='define'
ptrsize='4'
quadkind='5'
quadtype='__int64'
randbits='15'
randfunc='rand'
random_r_proto='0'
randseedtype='unsigned'
ranlib='rem'
rd_nodata='-1'
readdir64_r_proto='0'
readdir_r_proto='0'
revision='5'
rm='del'
rmail=''
run=''
runnm='true'
sPRIEUldbl='"E"'
sPRIFUldbl='"F"'
sPRIGUldbl='"G"'
sPRIXU64='"lX"'
sPRId64='"ld"'
sPRIeldbl='"e"'
sPRIfldbl='"f"'
sPRIgldbl='"g"'
sPRIi64='"li"'
sPRIo64='"lo"'
sPRIu64='"lu"'
sPRIx64='"lx"'
sSCNfldbl='"f"'
sched_yield=''
scriptdir='C:\Perl\bin'
scriptdirexp='C:\Perl\bin'
sed='sed'
seedfunc='srand'
selectminbits='32'
selecttype='Perl_fd_set *'
sendmail='blat'
setgrent_r_proto='0'
sethostent_r_proto='0'
setlocale_r_proto='0'
setnetent_r_proto='0'
setprotoent_r_proto='0'
setpwent_r_proto='0'
setservent_r_proto='0'
sh='cmd /x /c'
shar=''
sharpbang='#!'
shmattype='void *'
shortsize='2'
shrpenv=''
shsharp='true'
sig_count='26'
sig_name='ZERO HUP INT QUIT ILL NUM05 NUM06 NUM07 FPE KILL NUM10 SEGV NUM12 PIPE ALRM TERM NUM16 NUM17 NUM18 NUM19 CHLD BREAK ABRT STOP NUM24 CONT CLD'
sig_name_init='"ZERO", "HUP", "INT", "QUIT", "ILL", "NUM05", "NUM06", "NUM07", "FPE", "KILL", "NUM10", "SEGV", "NUM12", "PIPE", "ALRM", "TERM", "NUM16", "NUM17", "NUM18", "NUM19", "CHLD", "BREAK", "ABRT", "STOP", "NUM24", "CONT", "CLD", 0'
sig_num='0 1 2 21 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 20'
sig_num_init='0, 1, 2, 21, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 0'
sig_size='27'
signal_t='void'
sitearch='C:\Perl\site\lib'
sitearchexp='C:\Perl\site\lib'
sitebin='C:\Perl\site\bin'
sitebinexp='C:\Perl\site\bin'
sitehtml1dir=''
sitehtml1direxp=''
sitehtml3dir=''
sitehtml3direxp=''
sitelib='C:\Perl\site\lib'
sitelib_stem=''
sitelibexp='C:\Perl\site\lib'
siteman1dir=''
siteman1direxp=''
siteman3dir=''
siteman3direxp=''
siteprefix='C:\Perl\site'
siteprefixexp='C:\Perl\site'
sitescript=''
sitescriptexp=''
sizesize='4'
sizetype='size_t'
sleep=''
smail=''
so='dll'
sockethdr=''
socketlib=''
socksizetype='int'
sort='sort'
spackage='Perl5'
spitshell=''
srand48_r_proto='0'
srandom_r_proto='0'
src=''
ssizetype='int'
startperl='#!perl'
startsh='#!/bin/sh'
static_ext='Win32CORE'
stdchar='char'
stdio_base='((fp)->_base)'
stdio_bufsiz='((fp)->_cnt + (fp)->_ptr - (fp)->_base)'
stdio_cnt='((fp)->_cnt)'
stdio_filbuf=''
stdio_ptr='((fp)->_ptr)'
stdio_stream_array=''
strerror_r_proto='0'
strings='/usr/include/string.h'
submit=''
subversion=''
sysman='/usr/man/man1'
tail=''
tar=''
targetarch=''
tbl=''
tee=''
test=''
timeincl='/usr/include/sys/time.h '
timetype='time_t'
tmpnam_r_proto='0'
to=':'
touch='touch'
tr=''
trnl='\012'
troff=''
ttyname_r_proto='0'
u16size='2'
u16type='unsigned short']



[unalloc_21_270336_129388032, sitehtml3direxp=''
sitelib='C:\Perl\site\lib'
sitelib_stem=''
sitelibexp='C:\Perl\site\lib'
siteman1dir=''
siteman1direxp=''
siteman3dir=''
siteman3direxp=''
siteprefix='C:\Perl\site'
siteprefixexp='C:\Perl\site'
sitescript=''
sitescriptexp=''
sizesize='4'
sizetype='size_t'
sleep=''
smail=''
so='dll'
sockethdr=''
socketlib=''
socksizetype='int'
sort='sort'
spackage='Perl5'
spitshell=''
srand48_r_proto='0'
srandom_r_proto='0'
src=''
ssizetype='int'
startperl='#!perl'
startsh='#!/bin/sh'
static_ext='Win32CORE'
stdchar='char'
stdio_base='((fp)->_base)'
stdio_bufsiz='((fp)->_cnt + (fp)->_ptr - (fp)->_base)'
stdio_cnt='((fp)->_cnt)'
stdio_filbuf=''
stdio_ptr='((fp)->_ptr)'
stdio_stream_array=''
strerror_r_proto='0'
strings='/usr/include/string.h'
submit=''
subversion=''
sysman='/usr/man/man1'
tail=''
tar=''
targetarch=''
tbl=''
tee=''
test=''
timeincl='/usr/include/sys/time.h '
timetype='time_t'
tmpnam_r_proto='0'
to=':'
touch='touch'
tr=''
trnl='\012'
troff=''
ttyname_r_proto='0'
u16size='2'
u16type='unsigned short'
u32size='4'
u32type='unsigned long'
u64size='8'
u64type='unsigned __int64'
u8size='1'
u8type='unsigned char'
uidformat='"ld"'
uidsign='-1'
uidsize='4'
uidtype='uid_t'
uname='uname'
uniq='uniq'
uquadtype='unsigned __int64'
use5005threads='undef'
use64bitall='undef'
use64bitint='undef'
usecrosscompile='undef'
usedl='define'
usefaststdio='undef'
useithreads='define'
uselargefiles='define'
uselongdouble='undef'
usemallocwrap='define'
usemorebits='undef'
usemultiplicity='define'
usemymalloc='n'
usenm='false'
useopcode='true'
useperlio='define'
useposix='true'
usereentrant='undef'
userelocatableinc='undef'
usesfio='false'
useshrplib='true'
usesitecustomize='define'
usesocks='undef'
usethreads='define'
usevendorprefix='undef'
usevfork='false'
usrinc='/usr/include'
uuname=''
uvXUformat='"lX"'
uvoformat='"lo"'
uvsize='4'
uvtype='unsigned long'
uvuformat='"lu"'
uvxformat='"lx"'
vendorarch=''
vendorarchexp=''
vendorbin=''
vendorbinexp=''
vendorhtml1dir=' '
vendorhtml1direxp=''
vendorhtml3dir=' '
vendorhtml3direxp=''
vendorlib=''
vendorlib_stem=''
vendorlibexp=''
vendorman1dir=' '
vendorman1direxp=''
vendorman3dir=' '
vendorman3direxp=''
vendorprefix=''
vendorprefixexp=''
vendorscript=''
vendorscriptexp=''
version='5.10.0'
version_patchlevel_string='version 10 subversion 0'
versiononly='undef'
vi=''
voidflags='15'
xlibpth='/usr/lib/386 /lib/386'
yacc='yacc'
yaccflags=''
zcat=''
zip='zip'
!END!
my $i = 0;
foreach my $c (4,3,2) { $i |= ord($c); $i <<= 8 }
$i |= ord(1);
our $byteorder = join('', unpack('aaaa', pack('L!', $i)));
s/(byteorder=)(['"]).*?\2/$1$2$Config::byteorder$2/m;
my $config_sh_len = length $_;
our $Config_SH_expanded = "\n$_" . << 'EOVIRTUAL';
ccflags_nolargefiles='-nologo -GF -W3 -MD -Zi -DNDEBUG -O1 -DWIN32 -D_CONSOLE -DNO_STRICT -DHAVE_DES_FCRYPT -DUSE_SITECUSTOMIZE -DPRIVLIB_LAST_IN_INC -DPERL_IMPLICIT_CONTEXT -DPERL_IMPLICIT_SYS -DUSE_PERLIO -DPERL_MSVCRT_READFIX'
ldflags_nolargefiles='-nologo -nodefaultlib -debug -opt:ref,icf  -libpath:"C:\Perl\lib\CORE"  -machine:x86'
libs_nolargefiles=''
libswanted_nolargefiles=''
EOVIRTUAL
# Search for it in the big string
sub fetch_string {
    my($self, $key) = @_;
    # Let ActivePerl::Config override if it wants
    my $value;
    $value = _fetch_string(@_)
        unless defined(&ActivePerl::Config::override) &&
               ActivePerl::Config::override($key, $value);
    return $self->{$key} = $value; # cache it
sub _fetch_string {
    my($self, $key) = @_;
    # We only have ' delimted.
    my $start = index($Config_SH_expanded, "\n$key=\'");
    # Start can never be -1 now, as we've rigged the long string we're
    # searching with an initial dummy newline.
    return undef if $start == -1;
    $start += length($key) + 3;
    my $value = substr($Config_SH_expanded, $start,
                       index($Config_SH_expanded, "'\n", $start)
		       - $start);
    # So we can say "if $Config{'foo'}".
    $value = undef if $value eq 'undef';
    return $value;
my $prevpos = 0;
sub FIRSTKEY {
    $prevpos = 0;
    substr($Config_SH_expanded, 1, index($Config_SH_expanded, '=') - 1 );
sub NEXTKEY {
    my $pos = index($Config_SH_expanded, qq('\n), $prevpos) + 2;
    my $len = index($Config_SH_expanded, "=", $pos) - $pos;
    $prevpos = $pos;
    $len > 0 ? substr($Config_SH_expanded, $pos, $len) : undef;
sub EXISTS {
    return 1 if exists($_[0]->{$_[1]});
    return(index($Config_SH_expanded, "\n$_[1]='") != -1
          );
sub STORE  { die "\%Config::Config is read-only\n" }
*DELETE = \&STORE;
*CLEAR  = \&STORE;
sub config_sh {
    substr $Config_SH_expanded, 1, $config_sh_len;
sub config_re {
    my $re = shift;
    return map { chomp; $_ } grep eval{ /^(?:$re)=/ }, split /^/,
    $Config_SH_expanded;
sub config_vars {
    # implements -V:cfgvar option (see perlrun -V:)
    foreach (@_) {
	# find optional leading, trailing colons; and query-spec
	my ($notag,$qry,$lncont) = m/^(:)?(.*?)(:)?$/;	# flags fore and aft, 
	# map colon-flags to print decorations
	my $prfx = $notag ? '': "$qry=";		# tag-prefix for print
	my $lnend = $lncont ? ' ' : ";\n";		# line ending for print
	# all config-vars are by definition \w only, any \W means regex
	if ($qry =~ /\W/) {
	    my @matches = config_re($qry);
	    print map "$_$lnend", @matches ? @matches : "$qry: not found"		if !$notag;
	    print map { s/\w+=//; "$_$lnend" } @matches ? @matches : "$qry: not found"	if  $notag;
	} else {
	    my $v = (exists $Config::Config{$qry}) ? $Config::Config{$qry}
						   : 'UNKNOWN';
	    $v = 'undef' unless defined $v;
	    print "${prfx}'${v}'$lnend";
    }
# Called by the real AUTOLOAD
sub launcher {
    undef &AUTOLOAD;
    goto \&$Config::AUTOLOAD;
FILE
dcb3db9e/Cwd.pm
<F#line 1 "C:/Perl/lib/Cwd.pm"
package Cwd;
#line 169
use strict;
use Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
$VERSION = '3.2501';
@ISA = qw/ Exporter /;
@EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
@EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
# sys_cwd may keep the builtin command
# All the functionality of this module may provided by builtins,
# there is no sense to process the rest of the file.
# The best choice may be to have this in BEGIN, but how to return from BEGIN?
if ($^O eq 'os2') {
    local $^W = 0;
    *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
    *getcwd             = \&cwd;
    *fastgetcwd         = \&cwd;
    *fastcwd            = \&cwd;
    *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
    *abs_path           = \&fast_abs_path;
    *realpath           = \&fast_abs_path;
    *fast_realpath      = \&fast_abs_path;
    return 1;
# If loading the XS stuff doesn't work, we can fall back to pure perl
eval {
  if ( $] >= 5.006 ) {
    require XSLoader;
    XSLoader::load( __PACKAGE__, $VERSION );
  } else {
    require DynaLoader;
    push @ISA, 'DynaLoader';
    __PACKAGE__->bootstrap( $VERSION );
# Must be after the DynaLoader stuff:
$VERSION = eval $VERSION;
# Big nasty table of function aliases
my %METHOD_MAP =
   VMS =>
   {
    cwd			=> '_vms_cwd',
    getcwd		=> '_vms_cwd',
    fastcwd		=> '_vms_cwd',
    fastgetcwd		=> '_vms_cwd',
    abs_path		=> '_vms_abs_path',
    fast_abs_path	=> '_vms_abs_path',
   },
   MSWin32 =>
   {
    # We assume that &_NT_cwd is defined as an XSUB or in the core.
    cwd			=> '_NT_cwd',
    getcwd		=> '_NT_cwd',
    fastcwd		=> '_NT_cwd',
    fastgetcwd		=> '_NT_cwd',
    abs_path		=> 'fast_abs_path',
    realpath		=> 'fast_abs_path',
   },
   dos => 
   {
    cwd			=> '_dos_cwd',
    getcwd		=> '_dos_cwd',
    fastgetcwd		=> '_dos_cwd',
    fastcwd		=> '_dos_cwd',
    abs_path		=> 'fast_abs_path',
   },
   qnx =>
   {
    cwd			=> '_qnx_cwd',
    getcwd		=> '_qnx_cwd',
    fastgetcwd		=> '_qnx_cwd',
    fastcwd		=> '_qnx_cwd',
    abs_path		=> '_qnx_abs_path',
    fast_abs_path	=> '_qnx_abs_path',
   },
   cygwin =>
   {
    getcwd		=> 'cwd',
    fastgetcwd		=> 'cwd',
    fastcwd		=> 'cwd',
    abs_path		=> 'fast_abs_path',
    realpath		=> 'fast_abs_path',
   },
   epoc =>
   {
    cwd			=> '_epoc_cwd',
    getcwd	        => '_epoc_cwd',
    fastgetcwd		=> '_epoc_cwd',
    fastcwd		=> '_epoc_cwd',
    abs_path		=> 'fast_abs_path',
   },
   MacOS =>
   {
    getcwd		=> 'cwd',
    fastgetcwd		=> 'cwd',
    fastcwd		=> 'cwd',
    abs_path		=> 'fast_abs_path',
   },
  );
$METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
$METHOD_MAP{nto} = $METHOD_MAP{qnx};
# Find the pwd command in the expected locations.  We assume these
# are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
# so everything works under taint mode.
my $pwd_cmd;
foreach my $try ('/bin/pwd',
		 '/usr/bin/pwd',
		 '/QOpenSys/bin/pwd', # OS/400 PASE.
		) {
    if( -x $try ) {
        $pwd_cmd = $try;
        last;
    }
my $found_pwd_cmd = defined($pwd_cmd);
unless ($pwd_cmd) {
    # Isn't this wrong?  _backtick_pwd() will fail if somenone has
    # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
    # See [perl #16774]. --jhi
    $pwd_cmd = 'pwd';
# Lazy-load Carp
sub _carp  { require Carp; Carp::carp(@_)  }
sub _croak { require Carp; Carp::croak(@_) }
# The 'natural and safe form' for UNIX (pwd may be setuid root)
sub _backtick_pwd {
    # Localize %ENV entries in a way that won't create new hash keys
    my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
    local @ENV{@localize};
    
    my $cwd = `$pwd_cmd`;
    # Belt-and-suspenders in case someone said "undef $/".
    local $/ = "\n";
    # `pwd` may fail e.g. if the disk is full
    chomp($cwd) if defined $cwd;
    $cwd;
# Since some ports may predefine cwd internally (e.g., NT)
# we take care not to override an existing definition for cwd().
unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
    # The pwd command is not available in some chroot(2)'ed environments
    my $sep = $Config::Config{path_sep} || ':';
    my $os = $^O;  # Protect $^O from tainting
    # Try again to find a pwd, this time searching the whole PATH.
    if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
	my @candidates = split($sep, $ENV{PATH});
	while (!$found_pwd_cmd and @candidates) {
	    my $candidate = shift @candidates;
	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
    }
    # MacOS has some special magic to make `pwd` work.
    if( $os eq 'MacOS' || $found_pwd_cmd )
    {
	*cwd = \&_backtick_pwd;
    }
    else {
	*cwd = \&getcwd;
    }
if ($^O eq 'cygwin') {
  # We need to make sure cwd() is called with no args, because it's
  # got an arg-less prototype and will die if args are present.
  local $^W = 0;
  my $orig_cwd = \&cwd;
  *cwd = sub { &$orig_cwd() }
# set a reasonable (and very safe) default for fastgetcwd, in case it
# isn't redefined later (20001212 rspier)
*fastgetcwd = \&cwd;
# A non-XS version of getcwd() - also used to bootstrap the perl build
# process, when miniperl is running and no XS loading happens.
sub _perl_getcwd
    abs_path('.');
# By John Bazik
# Usage: $cwd = &fastcwd;
# This is a faster version of getcwd.  It's also more dangerous because
# you might chdir out of a directory that you can't chdir back into.
    
sub fastcwd_ {
    my($odev, $oino, $cdev, $cino, $tdev, $tino);
    my(@path, $path);
    local(*DIR);
    my($orig_cdev, $orig_cino) = stat('.');
    ($cdev, $cino) = ($orig_cdev, $orig_cino);
    for (;;) {
	my $direntry;
	($odev, $oino) = ($cdev, $cino);
	CORE::chdir('..') || return undef;
	($cdev, $cino) = stat('.');
	last if $odev == $cdev && $oino == $cino;
	opendir(DIR, '.') || return undef;
	for (;;) {
	    $direntry = readdir(DIR);
	    last unless defined $direntry;
	    next if $direntry eq '.';
	    next if $direntry eq '..';
	    ($tdev, $tino) = lstat($direntry);
	    last unless $tdev != $odev || $tino != $oino;
	closedir(DIR);
	return undef unless defined $direntry; # should never happen
	unshift(@path, $direntry);
    }
    $path = '/' . join('/', @path);
    if ($^O eq 'apollo') { $path = "/".$path; }
    # At this point $path may be tainted (if tainting) and chdir would fail.
    # Untaint it then check that we landed where we started.
    $path =~ /^(.*)\z/s		# untaint
	&& CORE::chdir($1) or return undef;
    ($cdev, $cino) = stat('.');
    die "Unstable directory path, current directory changed unexpectedly"
	if $cdev != $orig_cdev || $cino != $orig_cino;
    $path;
if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
# Keeps track of current working directory in PWD environment var
# Usage:
#	use Cwd 'chdir';
#	chdir $newdir;
my $chdir_init = 0;
sub chdir_init {
    if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
	my($dd,$di) = stat('.');
	my($pd,$pi) = stat($ENV{'PWD'});
	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
	    $ENV{'PWD'} = cwd();
    }
    else {
	my $wd = cwd();
	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
	$ENV{'PWD'} = $wd;
    }
    # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
    if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
	my($pd,$pi) = stat($2);
	my($dd,$di) = stat($1);
	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
	    $ENV{'PWD'}="$2$3";
    }
    $chdir_init = 1;
sub chdir {
    my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
    $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
    chdir_init() unless $chdir_init;
    my $newpwd;
    if ($^O eq 'MSWin32') {
	# get the full path name *before* the chdir()
	$newpwd = Win32::GetFullPathName($newdir);
    }
    return 0 unless CORE::chdir $newdir;
    if ($^O eq 'VMS') {
	return $ENV{'PWD'} = $ENV{'DEFAULT'}
    }
    elsif ($^O eq 'MacOS') {
	return $ENV{'PWD'} = cwd();
    }
    elsif ($^O eq 'MSWin32') {
	$ENV{'PWD'} = $newpwd;
	return 1;
    }
    if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
	$ENV{'PWD'} = cwd();
    } elsif ($newdir =~ m#^/#s) {
	$ENV{'PWD'} = $newdir;
    } else {
	my @curdir = split(m#/#,$ENV{'PWD'});
	@curdir = ('') unless @curdir;
	my $component;
	foreach $component (split(m#/#, $newdir)) {
	    next if $component eq '.';
	    pop(@curdir),next if $component eq '..';
	    push(@curdir,$component);
	$ENV{'PWD'} = join('/',@curdir) || '/';
    }
    1;
sub _perl_abs_path
    my $start = @_ ? shift : '.';
    my($dotdots, $cwd, @pst, @cst, $dir, @tst);
    unless (@cst = stat( $start ))
    {
	_carp("stat($start): $!");
	return '';
    }
    unless (-d _) {
        # Make sure we can be invoked on plain files, not just directories.
        # NOTE that this routine assumes that '/' is the only directory separator.
        my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
	    or return cwd() . '/' . $start;
	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
	if (-l $start) {
	    my $link_target = readlink($start);
	    die "Can't resolve link $start: $!" unless defined $link_target;
	    
	    require File::Spec;
            $link_target = $dir . '/' . $link_target
                unless File::Spec->file_name_is_absolute($link_target);
	    
	    return abs_path($link_target);
	return $dir ? abs_path($dir) . "/$file" : "/$file";
    }
    $cwd = '';
    $dotdots = $start;
    do
    {
	$dotdots .= '/..';
	@pst = @cst;
	local *PARENT;
	unless (opendir(PARENT, $dotdots))
	    _carp("opendir($dotdots): $!");
	    return '';
	unless (@cst = stat($dotdots))
	    _carp("stat($dotdots): $!");
	    closedir(PARENT);
	    return '';
	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
	    $dir = undef;
	else
	    do
	    {
		unless (defined ($dir = readdir(PARENT)))
	        {
		    _carp("readdir($dotdots): $!");
		    closedir(PARENT);
		    return '';
		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
	    }
	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
		   $tst[1] != $pst[1]);
	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
	closedir(PARENT);
    } while (defined $dir);
    chop($cwd) unless $cwd eq '/'; # drop the trailing /
    $cwd;
my $Curdir;
sub fast_abs_path {
    local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
    my $cwd = getcwd();
    require File::Spec;
    my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
    # Detaint else we'll explode in taint mode.  This is safe because
    # we're not doing anything dangerous with it.
    ($path) = $path =~ /(.*)/;
    ($cwd)  = $cwd  =~ /(.*)/;
    unless (-e $path) {
 	_croak("$path: No such file or directory");
    }
    unless (-d _) {
        # Make sure we can be invoked on plain files, not just directories.
	my ($vol, $dir, $file) = File::Spec->splitpath($path);
	return File::Spec->catfile($cwd, $path) unless length $dir;
	if (-l $path) {
	    my $link_target = readlink($path);
	    die "Can't resolve link $path: $!" unless defined $link_target;
	    
	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                unless File::Spec->file_name_is_absolute($link_target);
	    
	    return fast_abs_path($link_target);
	return $dir eq File::Spec->rootdir
	  ? File::Spec->catpath($vol, $dir, $file)
	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
    }
    if (!CORE::chdir($path)) {
 	_croak("Cannot chdir to $path: $!");
    }
    my $realpath = getcwd();
    if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
 	_croak("Cannot chdir back to $cwd: $!");
    }
    $realpath;
# added function alias to follow principle of least surprise
# based on previous aliasing.  --tchrist 27-Jan-00
*fast_realpath = \&fast_abs_path;
# --- PORTING SECTION ---
# VMS: $ENV{'DEFAULT'} points to default directory at all times
# 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
# Note: Use of Cwd::chdir() causes the logical name PWD to be defined
#   in the process logical name table as the default device and directory
#   seen by Perl. This may not be the same as the default device
#   and directory seen by DCL after Perl exits, since the effects
#   the CRTL chdir() function persist only until Perl exits.
sub _vms_cwd {
    return $ENV{'DEFAULT'};
sub _vms_abs_path {
    return $ENV{'DEFAULT'} unless @_;
    my $path = shift;
    if (-l $path) {
        my $link_target = readlink($path);
        die "Can't resolve link $path: $!" unless defined $link_target;
	    
        return _vms_abs_path($link_target);
    }
    # may need to turn foo.dir into [.foo]
    my $pathified = VMS::Filespec::pathify($path);
    $path = $pathified if defined $pathified;
    return VMS::Filespec::rmsexpand($path);
sub _os2_cwd {
    $ENV{'PWD'} = `cmd /c cd`;
    chomp $ENV{'PWD'};
    $ENV{'PWD'} =~ s:\\:/:g ;
    return $ENV{'PWD'};
sub _win32_cwd {
    if (defined &DynaLoader::boot_DynaLoader) {
	$ENV{'PWD'} = Win32::GetCwd();
    }
    else { # miniperl
	chomp($ENV{'PWD'} = `cd`);
    }
    $ENV{'PWD'} =~ s:\\:/:g ;
    return $ENV{'PWD'};
*_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_os2_cwd;
sub _dos_cwd {
    if (!defined &Dos::GetCwd) {
        $ENV{'PWD'} = `command /c cd`;
        chomp $ENV{'PWD'};
        $ENV{'PWD'} =~ s:\\:/:g ;
    } else {
        $ENV{'PWD'} = Dos::GetCwd();
    }
    return $ENV{'PWD'};
sub _qnx_cwd {
	local $ENV{PATH} = '';
	local $ENV{CDPATH} = '';
	local $ENV{ENV} = '';
    $ENV{'PWD'} = `/usr/bin/fullpath -t`;
    chomp $ENV{'PWD'};
    return $ENV{'PWD'};
sub _qnx_abs_path {
	local $ENV{PATH} = '';
	local $ENV{CDPATH} = '';
	local $ENV{ENV} = '';
    my $path = @_ ? shift : '.';
    local *REALPATH;
    defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
      die "Can't open /usr/bin/fullpath: $!";
    my $realpath = <REALPATH>;
    close REALPATH;
    chomp $realpath;
    return $realpath;
sub _epoc_cwd {
    $ENV{'PWD'} = EPOC::getcwd();
    return $ENV{'PWD'};
# Now that all the base-level functions are set up, alias the
# user-level functions to the right places
if (exists $METHOD_MAP{$^O}) {
  my $map = $METHOD_MAP{$^O};
  foreach my $name (keys %$map) {
    local $^W = 0;  # assignments trigger 'subroutine redefined' warning
    no strict 'refs';
    *{$name} = \&{$map->{$name}};
# In case the XS version doesn't load.
*abs_path = \&_perl_abs_path unless defined &abs_path;
*getcwd = \&_perl_getcwd unless defined &getcwd;
# added function alias for those of us more
# used to the libc function.  --tchrist 27-Jan-00
*realpath = \&abs_path;
FILE
5bfeecdf/DynaLoader.pm
#line 1 "C:/Perl/lib/DynaLoader.pm"
# Generated from DynaLoader_pm.PL
package DynaLoader;
#   And Gandalf said: 'Many folk like to know beforehand what is to
#   be set on the table; but those who have laboured to prepare the
#   feast like to keep their secret; for wonder makes the words of
#   praise louder.'
#   (Quote from Tolkien suggested by Anno Siegel.)
# See pod text at end of file for documentation.
# See also ext/DynaLoader/README in source tree for other information.
# 
Tim.Bunce@ig.co.uk, August 1994
BEGIN {
    $VERSION = '1.0803';
    $XS_VERSION = '1.0802';
require AutoLoader;
*AUTOLOAD = \&AutoLoader::AUTOLOAD;
use Config;
# enable debug/trace messages from DynaLoader perl code
$dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;
# Flags to alter dl_load_file behaviour.  Assigned bits:
#   0x01  make symbols available for linking later dl_load_file's.
#         (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
#         (ignored under VMS; effect is built-in to image linking)
# This is called as a class method $module->dl_load_flags.  The
# definition here will be inherited and result on "default" loading
# behaviour unless a sub-class of DynaLoader defines its own version.
sub dl_load_flags { 0x00 }
($dl_dlext, $dl_so, $dlsrc) = @Config::Config{qw(dlext so dlsrc)};
$do_expand = 0;
@dl_require_symbols = ();       # names of symbols we need
@dl_resolve_using   = ();       # names of files to link with
@dl_library_path    = ();       # path to look for files
#XSLoader.pm may have added elements before we were required
#@dl_shared_objects  = ();       # shared objects for symbols we have 
#@dl_librefs         = ();       # things we have loaded
#@dl_modules         = ();       # Modules we have loaded
# This is a fix to support DLD's unfortunate desire to relink -lc
@dl_resolve_using = dl_findfile('-lc') if $dlsrc eq "dl_dld.xs";
# Initialise @dl_library_path with the 'standard' library path
# for this platform as determined by Configure.
push(@dl_library_path, split(' ', $Config::Config{libpth}));
my $ldlibpthname         = $Config::Config{ldlibpthname};
my $ldlibpthname_defined = defined $Config::Config{ldlibpthname};
my $pthsep               = $Config::Config{path_sep};
# Add to @dl_library_path any extra directories we can gather from environment
# during runtime.
if ($ldlibpthname_defined &&
    exists $ENV{$ldlibpthname}) {
    push(@dl_library_path, split(/$pthsep/, $ENV{$ldlibpthname}));
# E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH.
if ($ldlibpthname_defined &&
    $ldlibpthname ne 'LD_LIBRARY_PATH' &&
    exists $ENV{LD_LIBRARY_PATH}) {
    push(@dl_library_path, split(/$pthsep/, $ENV{LD_LIBRARY_PATH}));
# No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.
# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB
boot_DynaLoader('DynaLoader') if defined(&boot_DynaLoader) &&
                                !defined(&dl_error);
if ($dl_debug) {
    print STDERR "DynaLoader.pm loaded (@INC, @dl_library_path)\n";
    print STDERR "DynaLoader not linked into this perl\n"
	    unless defined(&boot_DynaLoader);
1; # End of main code
sub croak   { require Carp; Carp::croak(@_)   }
sub bootstrap_inherit {
    my $module = $_[0];
    local *isa = *{"$module\::ISA"};
    local @isa = (@isa, 'DynaLoader');
    # Cannot goto due to delocalization.  Will report errors on a wrong line?
    bootstrap(@_);
# The bootstrap function cannot be autoloaded (without complications)
# so we define it here:
sub bootstrap {
    # use local vars to enable $module.bs script to edit values
    local(@args) = @_;
    local($module) = $args[0];
    local(@dirs, $file);
    unless ($module) {
	require Carp;
	Carp::confess("Usage: DynaLoader::bootstrap(module)");
    }
    # A common error on platforms which don't support dynamic loading.
    # Since it's fatal and potentially confusing we give a detailed message.
    croak("Can't load module $module, dynamic loading not available in this perl.\n".
	"  (You may need to build a new perl executable which either supports\n".
	"  dynamic loading or has the $module module statically linked into it.)\n")
	unless defined(&dl_load_file);
    
    my @modparts = split(/::/,$module);
    my $modfname = $modparts[-1];
    # Some systems have restrictions on files names for DLL's etc.
    # mod2fname returns appropriate file base name (typically truncated)
    # It may also edit @modparts if required.
    $modfname = &mod2fname(\@modparts) if defined &mod2fname;
    
    my $modpname = join('/',@modparts);
    print STDERR "DynaLoader::bootstrap for $module ",
		       "(auto/$modpname/$modfname.$dl_dlext)\n"
	if $dl_debug;
    foreach (@INC) {
	    my $dir = "$_/auto/$modpname";
	next unless -d $dir; # skip over uninteresting directories
	# check for common cases to avoid autoload of dl_findfile
	my $try =  "$dir/$modfname.$dl_dlext";
	last if $file = (-f $try) && $try;
	# no luck here, save dir for possible later dl_findfile search
	push @dirs, $dir;
    }
    # last resort, let dl_findfile have a go in all known locations
    $file = dl_findfile(map("-L$_",@dirs,@INC), $modfname) unless $file;
    croak("Can't locate loadable object for module $module in \@INC (\@INC contains: @INC)")
	unless $file;	# wording similar to error from 'require'
    
    my $bootname = "boot_$module";
    $bootname =~ s/\W/_/g;
    @dl_require_symbols = ($bootname);
    # Execute optional '.bootstrap' perl script for this module.
    # The .bs file can be used to configure @dl_resolve_using etc to
    # match the needs of the individual module on this architecture.
    my $bs = $file;
    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    if (-s $bs) { # only read file if it's not empty
        print STDERR "BS: $bs ($^O, $dlsrc)\n" if $dl_debug;
        eval { do $bs; };
        warn "$bs: $@\n" if $@;
    }
    my $boot_symbol_ref;
    
    # Many dynamic extension loading problems will appear to come from
    # this section of code: XYZ failed at line 123 of DynaLoader.pm.
    # Often these errors are actually occurring in the initialisation
    # C code of the extension XS file. Perl reports the error as being
    # in this perl code simply because this was the last perl code
    # it executed.
    my $libref = dl_load_file($file, $module->dl_load_flags) or
	croak("Can't load '$file' for module $module: ".dl_error());
    push(@dl_librefs,$libref);  # record loaded object
    my @unresolved = dl_undef_symbols();
    if (@unresolved) {
	require Carp;
	Carp::carp("Undefined symbols present after loading $file: @unresolved\n");
    }
    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
         croak("Can't find '$bootname' symbol in $file\n");
    push(@dl_modules, $module); # record loaded module
  boot:
    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
    # See comment block above
	push(@dl_shared_objects, $file); # record files loaded
    &$xs(@args);
#sub _check_file {   # private utility to handle dl_expandspec vs -f tests
#    my($file) = @_;
#    return $file if (!$do_expand && -f $file); # the common case
#    return $file if ( $do_expand && ($file=dl_expandspec($file)));
#    return undef;
# Let autosplit and the autoloader deal with these functions:
__END__
sub dl_findfile {
    # Read ext/DynaLoader/DynaLoader.doc for detailed information.
    # This function does not automatically consider the architecture
    # or the perl library auto directories.
    my (@args) = @_;
    my (@dirs,  $dir);   # which directories to search
    my (@found);         # full paths to real files we have found
    #my $dl_ext= 'dll'; # $Config::Config{'dlext'} suffix for perl extensions
    #my $dl_so = 'dll'; # $Config::Config{'so'} suffix for shared libraries
    print STDERR "dl_findfile(@args)\n" if $dl_debug;
    # accumulate directories but process files as they appear
    arg: foreach(@args) {
        #  Special fast case: full filepath requires no search
        if (m:/: && -f $_) {
	    push(@found,$_);
	    last arg unless wantarray;
	    next;
        # Deal with directories first:
        #  Using a -L prefix is the preferred option (faster and more robust)
        if (m:^-L:) { s/^-L//; push(@dirs, $_); next; }
        #  Otherwise we try to try to spot directories by a heuristic
        #  (this is a more complicated issue than it first appears)
        if (m:/: && -d $_) {   push(@dirs, $_); next; }
        #  Only files should get this far...
        my(@names, $name);    # what filenames to look for
        if (m:-l: ) {          # convert -lname to appropriate library name
            s/-l//;
            push(@names,"lib$_.$dl_so");
            push(@names,"lib$_.a");
        } else {                # Umm, a bare name. Try various alternatives:
            # these should be ordered with the most likely first
            push(@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
            push(@names,"lib$_.$dl_so")  unless m:/:;
	    
            push(@names,"$_.a")          if !m/\.a$/ and $dlsrc eq "dl_dld.xs";
            push(@names, $_);
        }
	my $dirsep = '/';
        foreach $dir (@dirs, @dl_library_path) {
            next unless -d $dir;
	    
            foreach $name (@names) {
		my($file) = "$dir$dirsep$name";
                print STDERR " checking in $dir for $name\n" if $dl_debug;
		$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);
		#$file = _check_file($file);
		if ($file) {
                    push(@found, $file);
                    next arg; # no need to look any further
                }
            }
        }
    }
    if ($dl_debug) {
        foreach(@dirs) {
            print STDERR " dl_findfile ignored non-existent directory: $_\n" unless -d $_;
        }
        print STDERR "dl_findfile found: @found\n";
    }
    return $found[0] unless wantarray;
    @found;
sub dl_expandspec {
    my($spec) = @_;
    # Optional function invoked if DynaLoader.pm sets $do_expand.
    # Most systems do not require or use this function.
    # Some systems may implement it in the dl_*.xs file in which case
    # this autoload version will not be called but is harmless.
    # This function is designed to deal with systems which treat some
    # 'filenames' in a special way. For example VMS 'Logical Names'
    # (something like unix environment variables - but different).
    # This function should recognise such names and expand them into
    # full file paths.
    # Must return undef if $spec is invalid or file does not exist.
    my $file = $spec; # default output to input
    
	return undef unless -f $file;
    
    print STDERR "dl_expandspec($spec) => $file\n" if $dl_debug;
    $file;
sub dl_find_symbol_anywhere
    my $sym = shift;
    my $libref;
    foreach $libref (@dl_librefs) {
	my $symref = dl_find_symbol($libref,$sym);
	return $symref if $symref;
    }
    return undef;
#line 775
FILE
67f6ea16/Errno.pm
{#line 1 "C:/Perl/lib/Errno.pm"
# This file is auto-generated. ***ANY*** changes here will be lost
package Errno;
our (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);
use Exporter ();
use Config;
use strict;
"$Config{'archname'}-$Config{'osvers'}" eq
"MSWin32-x86-multi-thread-5.00"]